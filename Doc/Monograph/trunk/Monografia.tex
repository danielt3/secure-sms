\documentclass[a4paper,capchap,espacoduplo,normaltoc]{abntepusp}

%\usepackage[bookmarks,pdftex,a4paper,colorlinks=true,citecolor=black,urlcolor=blue,linkcolor=black,pdfpagemode=None]{hyperref}
%\usepackage[bookmarks,a4paper,colorlinks=true,citecolor=black,urlcolor=blue,linkcolor=black,pdfpagemode=None]{hyperref}
\usepackage[centertags]{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage[brazil]{babel}
\usepackage[alf,abnt-repeated-author-omit=yes]{abntcite}
\usepackage{url}
%\usepackage{winfonts}
\usepackage{txfonts}
\usepackage{tabela-simbolos}
\usepackage{graphics}
\usepackage{rotating}


\fontfamily{arial}\selectfont
\renewcommand{\rmdefault}{arial}

% Math -------------------------------------------------------------------
\newtheorem{theorem}{Teorema}{\bfseries}{\itshape}
\newtheorem{lemma}{Lema}{\bfseries}{\itshape}
\newtheorem{definition}{Defini��o}{\bfseries}{\itshape}
\newtheorem{corollary}{Corol�rio}{\bfseries}{\itshape}

\newcommand{\samples}{\mathop{\stackrel{\,_\$}{\gets}}}

\sloppy

\begin{document}

\renewcommand{\bibname}{Refer\^encias} % adapta��o para ABNT/EPUSP

%\autorPoli{Eduardo}{Cruz}

%Gambis para definir m�ltiplos autores
\autor{\uppercase{Eduardo de Souza Cruz
	\\Geovandro Carlos Crepaldi Firmino Pereira
	\\Rodrigo Rodrigues da Silva}}
	
\renewcommand{\PoliAutorFichaCatalografica}{{Cruz, Eduardo de Souza\newline
 Pereira, Geovandro Carlos Crepaldi Firmino\newline
 Silva,Rodrigo Rodrigues}}
 

\newcommand{\F}{\mathbb{F}}
\newcommand{\G}{\mathbb{G}}
\newcommand{\ID}{\mathsf{ID}}
\newcommand{\Z}{\mathbb{Z}}
	
\titulo{Sistema de SMS Seguro}

\orientador{Prof. Dr. Paulo S�rgio Licciardi Messeder Barreto}

\monografiaFormatura
%\monografiaMBA
%\qualificacaoMSc{<�rea do Mestrado>}
%\qualificacaoMSc{Enge\-nharia El�trica}
%\dissertacao{<�rea do Mestrado>}
%\qualificacaoDr{<�rea do Mestrado>}
%\teseDr{<�rea do Doutorado>}
%\teseLD
%\memorialLD

%\comentario{\vspace{1.5cm}
%	Trabalho de Conclus�o de Curso
%	apresentado � Escola Polit�cnica da
%	Universidade de S�o Paulo para
%	obten��o do T�tulo de Engenheiro da
%	Computa��o.}%
  
\areaConcentracao{Engenharia da Computa��o}

\departamento{Departamento de Engenharia de Computa��o e Sistemas Digitais (PCS)}

\local{S�o Paulo}

\data{2008}

\dedicatoria{}

\capa{}

\falsafolhaderosto{}

\folhaderosto{}

%
% Ficha Catalogr�fica
% (deve ficar no verso da p�gina de rosto)
%
\renewcommand{\PoliFichaCatalograficaData}{% TODO: consertar
  1. Criptografia. 2. Dispositivos m�veis \#2. 3. Curvas El�pticas \#3.
  I. Universidade de S�o Paulo. Escola Polit�cnica.
  \PoliDepartamentoData. II. t.}

%\renewcommand{\PoliAutorFichaCatalografica}{{Cruz, Eduardo de Souza
%	\\Pereira, Geovandro Carlos Crepaldi Firmino
%	\\Silva, Rodrigo Rodrigues}}%

%TODO: porque ocorre 3 erros? Mas compila...
%\fichacatalografica % formata a ficha

\paginadedicatoria{}

\begin{agradecimentos}
Ao nosso orientador Prof. Dr. Paulo S�rgio Licciardi Messeder Barreto, pelo envolvimento e constante incentivo ao projeto.

Aos nossos familiares, por fornecer o suporte necess�rio para alcan�armos nossos objetivos e por compreenderem nossa constante aus�ncia nos �ltimos meses.

Aos nossos professores, por guiar-nos na busca pelo conhecimento necess�rio � realiza��o do trabalho.

Aos nossos colegas, que sempre nos apoiaram e ajudaram a superar as dificuldades enfrentadas durante o curso.

Ao Andr� Felipe Santos, por auxiliar-nos na realiza��o dos testes finais.

Ao Felipe Sanches, por ter criado o �cone do aplicativo.

\end{agradecimentos}

\begin{resumo}
Este trabalho consiste na especifica��o, projeto e implementa��o de um sistema que garanta servi�os de seguran�a na troca de mensagens \emph{SMS} entre aparelhos de telefonia celular. 

A necessidade da implementa��o de mais uma camada de seguran�a sobre a rede de telefonia celular \emph{GSM} justifica-se pelo fato de as mensagens trafegarem pela rede interna da operadora sem qualquer mecanismo de seguran�a, deixando-a vulner�vel a quaisquer atacantes que comprometam o sistema e tenham acesso � sua base de dados SMS, incluindo funcion�rios mal intencionados. Desse modo, aplica��es que requeiram seguran�a ficam impossibilitadas de se aproveitar das qualidades desse meio: mobilidade, leveza e baixo custo.

Os paradigmas de seguran�a atualmente empregados na \emph{Internet} n�o s�o adequados a esse cen�rio, uma vez que h� grandes limita��es de banda e poder de processamento. Analisamos os conceitos relativamente recentes de Criptografia de Curvas El�pticas e Criptografia Baseada em Identidades, chegando a um esquema h�brido entre essas e a criptografia de chave p�blica convencional que atende aos requisitos estabelecidos.

Ao longo da monografia, apresentaremos aspectos da nossa solu��o, m�tricas, detalhes do protocolo criptogr�fico que viabilizou a implementa��o, especifica��o do sistema e resultados de testes de desempenho do sistema implementado.
\end{resumo}

\begin{abstract}
This work consists of the specification, design and implementation of a system that guarantees security services to the mobile Short Message Service (\emph{SMS}). 

The need of an extra security layer onto the \emph{GSM} network resides on the fact that short messages are exchanged through the carrier's internal network as plain text, vulnerable to any attacker that manages to compromise the system and gain access to the SMS database, including malicious employees. Therefore, security-sensitive applications remain unable to take advantage from this media's best features: mobility, lightness and low cost.

The security paradigms currently adopted on the Internet don't fulfill this background's requirements, since there are strong bandwidth and processing restrictions. The analysis of the relatively recent concepts of Elliptic Curve Cryptography and Identity-Based Cryptography lead us to a hybrid scheme that assembles the best qualities of these and Public Key Cryptography and fulfills the established requirements.

Throughout this monograph, we are going to present aspects of our solution, metrics, details of the adopted cryptographic scheme, a system specification and performance test results.
\end{abstract}

\tableofcontents

\listoffigures

\listoftables

%TOLERADO: \sigla n�o funciona!!!
%To fazendo a lista de siglas na m�o... consertar depois talvez
\listadesiglas{
\begin{center}
\emph{\textbf{AES} - Advanced Encryption Standard}\\
\emph{\textbf{API} - Applicaiton Programming Interface}\\
\emph{\textbf{CLDC} - Connected Limited Device Configuration}\\
\emph{\textbf{DES} - Data Encryption Standard}\\
\emph{\textbf{DSA} - Digital Signature Algorithm}\\
\emph{\textbf{DSS} - Digital Signature System}\\
\emph{\textbf{DL} - Discrete Logarithm}\\
\emph{\textbf{ECC} - Elliptic Curve Cryptography}\\
\emph{\textbf{ECDLP} - Elliptic Curve Discrete Logarithm Problem}\\
\emph{\textbf{GSM} - Global System for Mobile Comunnication}\\
\emph{\textbf{IDE} - Integrated Development Environment}\\
\emph{\textbf{J2ME} - Java 2, Micro Edition}\\
\emph{\textbf{KGB} - Key Generation Bureau}\\
\emph{\textbf{MAC} - Message Authentication Code}\\
\emph{\textbf{MTTF} - Mean Time To Fail}\\
\emph{\textbf{MIDP} - Mobile Information Device Profile}\\
\emph{\textbf{PKI} - Private Key Infrastructure}\\
\emph{\textbf{RC4} - Rivest Cipher 4}\\
\emph{\textbf{RSA} - Rivest, Shamir, Adleman}\\
\emph{\textbf{SMS} - Short Message Service}\\
\emph{\textbf{SMSC} - Short Message Service Center}\\
\emph{\textbf{SMTP} - Simple Mail Transfer Protocol}\\
\emph{\textbf{VPN} - Virtual Private Network}\\
\emph{\textbf{WMA} - Wireless Messaging API}\\
\emph{\textbf{WTK} - Wireless Toolkit}\\
%Existe uma norma, acho que � pra por na ordem de apari��o no texto... ou em ordem alfab�tica.. n�o sei, TOLERADO: confirmar nas diretrizes
\end{center}
}


\chapter{Introdu��o}

O Servi�o de Mensagens Curtas (\emph{Short Message Service}, ou SMS) � um servi�o oferecido por operadoras de telefonia celular para que seus usu�rios troquem mensagens curtas de texto com outros usu�rios da rede ou com servi�os da Internet. Atualmente, cerca de 2.4 bilh�es de pessoas utilizam o SMS no mundo.

Comercialmente, as mensagens SMS moveram uma massiva ind�stria em 2006, com cerca de 81 bilh�es de d�lares no mundo. Mensagens SMS tem um pre�o m�dio global de 0.11 d�lares e mant�m uma margem de lucro de quase 90\%. Em 2010 cerca de 2.3 trilh�es de mensagens de texto ser�o enviadas no mundo, gerando 72.5 bilh�es de d�lares para as operadoras de celular, de acordo com previs�es realizadas no ano de 2006 pela Gartner Dataquest. A maioria deles transformam-se em lucro, porque a margem de lucro em mensagens de texto flutua em cerca de 90\%, mais que o dobro do que as operadoras obt�m com servi�os de voz. \cite{sylvers}


A rede GSM (Global System for Mobile Comunnication), sobre a qual as mensagens SMS trafegam, usa o mecanismo \emph{store-and-forward}, que � similar ao servi�o SMTP de correio eletr�nico. Em vez de servidores de \emph{e-mail}, s�o usados centros de SMS (SMSC) que armazenam as mensagens SMS antes de serem enviadas para o fornecedor de servi�os (operadora) ou para outro SMSC.

Embora as conex�es entre um SMSC e os n�s da rede GSM sejam protegidas por t�neis VPN, as mensagens SMS ficam armazenadas em texto claro no SMSC. Isto significa que os operadores ou um atacante que invada o sistema podem visualizar e alterar o conte�do de todas as mensagens SMS que est�o armazenadas no SMSC, al�m de enviar mensagens em nome de outrem \cite{loon}.

Al�m de comprometer a privacidade dos usu�rios, essa vulnerabilidade da rede GSM limita usos da tecnologia SMS al�m da comunica��o interpessoal, como a realiza��o de transa��es banc�rias, sistemas de comunica��o que requeiram confidencialidade e integridade (�rg�os militares e governamentais, comunica��o corporativa) ou ainda servi�os de monitora��o remota de dados sens�veis \cite{smsanalysis}.

Desse modo, nos motivamos a projetar e implementar um sistema que oferecesse servi�os de seguran�a � plataforma SMS de maneira transparente, isto �, sem que fossem necess�rias mudan�as na rede atual e, por outro lado, fosse vi�vel em dispositivos m�veis, dada suas limita��es de banda, processamento e energia.

\section{Cen�rio} %Falar dos limitantes, processamento e tamanho de mensagem pequenos

\subsection{Alternativas existentes}
Atualmente n�o existem solu��es universalmente adotadas para garantir seguran�a em mensagens SMS. Na maioria das transa��es as mensagens trafegam pela rede celular de forma insegura, passando obrigatoriamente por pelo menos um intermedi�rio n�o 100\% confi�vel: a operadora do servi�o de telefonia.

No in�cio de nossa pesquisa, as alternativas de sistemas de seguran�a pra SMS dispon�veis eram escassas. No decorrer do ano, diversas novas solu��es foram surgindo. %Listamos aqui algumas delas e resumimos suas principais caracter�sticas. 

%TODO listar solu��es atuais pelo geov�s

\subsection{Ambiente}
Na figura \ref{fig:Canal_Inseguro}, as entidades $A$ (Alice) e $B$ (Bob) est�o se comunicando sobre um canal inseguro. Assumimos que todas as comunica��es t�m a presen�a de um agressor $E$ (Eve) cujo objetivo � explorar falhas nos servi�os de seguran�a sendo fornecidos por $A$ e $B$.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.50\textwidth]{figuras/Canal_Inseguro.jpg}
	\caption{Canal inseguro}
	\label{fig:Canal_Inseguro}
\end{figure}

Por exemplo, $A$ e $B$ poderiam ser 2 pessoas comunicando-se sobre uma rede de telefonia celular, e $E$ est� tentando interceptar a comunica��o. 

Ou, $\tilde{A}$ poderia ser um \emph{web browser} de um indiv�duo $A$ que est� em processo de compra de um produto de uma loja \emph{on-line} $\tilde{B}$ representada por seu \emph{site} $B$. Neste cen�rio, o canal de comunica��es � a \emph{Internet}. Um agressor $E$ poderia tentar ler o tr�fego entre $A$ e $B$, portanto saber a informa��o sobre o cart�o de cr�dito de $A$, ou poderia tentar personificar $A$ ou $B$ na transa��o. 
Como um terceiro exemplo, considere a situa��o onde $A$ est� enviando uma mensagem via \emph{e-mail} para $B$ sobre a Internet. Um agressor $E$ poderia tentar ler a mensagem, modificar peda�os selecionados, ou personificar $A$ enviando mensagens dela mesma para $B$. Finalmente, considere o cen�rio onde $A$ � um smart card que est� em processo de autenticar seu possuidor $\tilde{A}$ em um computador \emph{mainframe} $B$ em uma sala protegida do banco. Aqui, $E$ poderia tentar monitorar as comunica��es para obter informa��es sobre a conta de $\tilde{A}$ , ou poderia tentar personificar $\tilde{A}$ para sacar fundos da conta de $\tilde{A}$. Deveria ser evidente destes exemplos que uma entidade se comunicando n�o � necessariamente um humano, mas pode ser um computador, \emph{smart card}, ou um m�dulo de software agindo no lugar de um indiv�duo ou uma organiza��o tal como uma loja ou um banco.\cite{menezes}

\section{Objetivos}

O ambiente em quest�o n�o se mostra muito prop�cio para pr�ticas criptogr�ficas. A largura de banda � muito pequena, visto que em cada mensagem SMS podem ser trafegados apenas 140 bytes bin�rios \cite{ortiz}.
Al�m disto, existem limita��es de processamento no dispositivo celular, que podem comprometer a usabilidade de um esquema criptogr�fico tradicional \cite{loon}.

Devido a estas dificuldades tecnol�gicas, o cen�rio atual n�o apresenta uma grande variedade de solu��es abrangendo os problemas de seguran�a supracitados. Desse modo, nos propomos a projetar, e implantar um sistema capaz de prover confidencialidade, integridade e autenticidade a mensagens SMS (\emph{Short Message Service}) sem extrapolar as limita��es de recursos computacionais e de ocupa��o de banda t�picas desse ambiente.

\section{Metodologia}

Nossa metodologia de pesquisa se dividiu basicamente em tr�s vertentes. A primeira consistiu no estudo do cen�rio, o detalhamento do problema e o levantamento das necessidades, al�m da especifica��o de uma solu��o que as endere�asse. 

Posteriormente, realizamos o estudo de esquemas de criptografia de modo a buscar o que mais se adequasse aos requisitos e limita��es do meio. Esse estudo incluiu a realiza��o de testes em microcomputadores convencionais e em dispositivos m�veis com pseudo-implementa��es de diversos esquemas com o objetivo de comparar seu desempenho em termos de necessidades de processamento. Como veremos, nenhum esquema pesquisado atendeu a nossos requisitos, o que motivou o desenvolvimento de um novo protocolo de seguran�a totalmente voltado a estes.

Por �ltimo, realizamos a implementa��o do sistema conforme sua especifica��o e realizamos testes de modo a confrontar os dados obtidos em um ambiente real com as previs�es feitas na fase anterior.

\section{Organiza��o}
O restante desta monografia organiza-se como se segue. No cap�tulo 2 apresentamos algumas preliminares te�ricas necess�rias ao desenvolvimento de nossa pesquisa e essenciais ao entendimento deste trabalho. O cap�tulo 3 aprofunda a discuss�o do tema, delineando o escopo do sistema e definindo m�tricas de avalia��o das solu��es estudadas. Os cap�tulos 4 a 7 apresentam a an�lise de requisitos e dos casos de uso do sistema e justificam as decis�es de projeto e implementa��o tomadas com base nessa an�lise. Em seguida, apresentamos os resultados obtidos e finalmente conclu�mos o trabalho.

\chapter{Preliminares te�ricas}% (assunto geral: curvas el�pticas, emparelhamento, identidadesz protocolos, conceitos, etc)

\section{Servi�os de Seguran�a}

Listamos abaixo alguns dos principais servi�os de seguran�a da informa��o:

\begin{itemize}
\item Confidencialidade: manter secretos os dados de todos a n�o ser �queles autorizados a acess�-los - mensagens enviadas por $A$ para $B$ n�o devem ser leg�veis por $E$ .
\item Integridade: assegurar que os dados n�o sejam alterados por entidades n�o autorizadas - $B$ deve ser capaz de detectar quando dados enviados por $A$ tenham sido modificados acidentalmente ou deliberadamente por um atacante $E$.
\item Autenticidade dos dados: confirmar a fonte dos dados - $B$ deve ser capaz de verificar que dados supostamente enviados por $A$ de fato foram originados por $A$.
\item Autenticidade da entidade: confirmar a identidade de determinada entidade: $B$ deve poder convencer-se da veracidade da identidade de $A$.
\item Irretratabilidade: prevenir uma entidade de negar comprometimentos ou atos anteriores - quando $B$ recebe uma mensagem supostamente de $A$, n�o apenas $B$ est� convencido de que a mensagem se originou em $A$, mas $B$ pode convencer uma terceira parte disso; portanto $A$ n�o pode negar ter enviado a mensagem para $B$.
Algumas aplica��es podem ter outros objetivos de seguran�a tais como anonimato das entidades em comunica��o ou controle de acesso (a restri��o de acessar recursos).
\end{itemize}


\section{Criptografia de Chave Sim�trica}

\subsection{Introdu��o}

Os sistemas criptogr�ficos podem ser amplamente divididos em dois tipos. Em esquemas de chave sim�trica, as entidades em comunica��o compartilham uma informa��o, usada como chave, que � ao mesmo tempo secreta e aut�ntica. Consequentemente, eles podem usar um esquema de encripta��o sim�trica tal como o \emph{Data Encryption Standard (DES)}, \emph{RC4}, ou o \emph{Advanced Encryption Standard (AES)} para prover o servi�o de confidencialidade. 

Eles tamb�m podem usar um algoritmo de c�digo de autentica��o de mensagens, tal como o \emph{HMAC}, para reunir os servi�os de integridade e autentica��o da origem dos dados.

Por exemplo, se confidencialidade fosse desejada e a chave secreta compartilhada entre $A$ e $B$ fosse $k$, ent�o $A$ encriptaria uma mensagem $m$, em texto claro, usando uma fun��o de encripta��o $ENC$ e a chave $k$ e transmitiria a cifra resultante $c - ENC_{k}(m)$ para $B$. Ao receber $c$, $B$ usaria a fun��o de decripta��o $DEC$ e a mesma chave $k$ para recuperar $m = DEC_{k}(c)$. 


\subsection{Administra��o e distribui��o de chaves}

A principal vantagem da criptografia de chave sim�trica � a alta efici�ncia. Contudo, h� significantes desvantagens nestes sistemas. Uma delas � o conhecido problema da distribui��o de chaves - a necessidade de um canal que seja secreto e autenticado para a distribui��o das chaves. Em algumas aplica��es, esta distribui��o pode ser convenientemente feita por usar um canal fisicamente seguro, tal como um emiss�rio de confian�a. Outra maneira � usar os servi�os de uma terceira parte confi�vel \emph{on-line} que inicialmente estabelece chaves secretas com todas as entidades na rede. Essa entidade usa essas chaves para distribuir as informa��es de chaves para as entidades em comunica��o quando requerido\footnote{Este modo de usar uma terceira parte centralizada para distribuir chaves para algoritmos de chave sim�trica �s partes conforme elas necessitarem � usado pelo protocolo de autentica��o da rede \emph{Kerberos} para aplica��es cliente/servidor.}. Solu��es como esta podem ser bem apropriadas para ambientes onde h� uma autoridade central aceit�vel e confi�vel, mas � claramente impratic�vel em aplica��es tal como \emph{e-mail} na \emph{Internet}.

Uma segunda desvantagem � o problema de administra��o de chaves. Em uma rede de $N$ entidades, cada entidade pode ter que manter diferentes informa��es de chaves com cada uma das $N-1$ entidades. Logo, seriam necess�rias $N(N-1)/2$ chaves privadas em toda a rede, o que inviabiliza a administra��o ao passo que $N$ se torna grande. Este problema pode ser aliviado usando servi�os de uma terceira parte \emph{on-line} que distribui as chaves conforme s�s requeridas, assim reduzindo a necessidade das entidades de armazenar m�ltiplas chaves seguramente. Novamente, contudo, tais solu��es n�o s�o pr�ticas em alguns cen�rios. Finalmente, uma vez que a informa��o sobre as chaves � compartilhada entre duas (ou mais) entidades, t�cnicas de chave sim�trica n�o podem ser usadas para implementar esquemas de assinatura digital (DSS) elegantes que forne�am servi�os de irretratabilidade. Isto porque � imposs�vel distinguir entre as a��es tomadas por diferentes detentores de uma chave secreta\footnote{Esquemas de assinaturas digitais podem ser implementados usando t�cnicas de chave sim�trica; contudo, estes esquemas geralmente s�o geralmente impratic�veis quando for requerido o uso de uma terceira parte confi�vel on-line ou de novas chaves para cada assinatura.}.\cite{menezes}

\section{Criptografia de chave p�blica}

\subsection{Introdu��o}
A no��o de criptografia de chave p�blica foi introduzida por Diffie e Hellman \cite{diffie-hellman} e Merkle \cite{merkle} para resolver as defici�ncias da criptografia de chaves sim�tricas mencionadas anteriormente. Em contraste aos esquemas de chave sim�trica, os esquemas de chave p�blica requerem apenas que as entidades em comunica��o troquem informa��es de chaves que s�o autenticas (mas n�o secretas). Cada entidade seleciona um �nico par $(e,d)$ consistindo de uma chave p�blica $e$, e uma chave privada relacionada $d$ que a entidade mant�m secreta). As chaves t�m a propriedade de que � computacionalmente impratic�vel determinar a chave privada apenas de conhecimento da chave p�blica.

\subsection{Confidencialidade}

Se a entidade $A$ deseja enviar uma mensagem confidencial $m$ para uma entidade $B$, ela obt�m uma c�pia aut�ntica da chave p�blica de $B$ $e_{B}$, e usa a fun��o de encripta��o $ENC$ de uma esquema de chave p�blica para computar a cifra $c = ENC_{e_{B}}(m)$. $A$ ent�o transmite $c$ para $B$, que usa a fun��o de decripta��o $DEC$ e sua chave privada $d_{B}$ para recuperar a mensagem clara: $m = DEC_{d_{B}}(c)$. A presun��o � que um agressor com posse apenas de $e_{B}$ (mas n�o de $d_{B}$) n�o consegue decriptar $c$. Observe-se que n�o h� nenhuma necessidade de discri��o de $e_{B}$. � essencial apenas que $A$ obtenha uma c�pia autentica de $e_{B}$ - por outro lado $A$ encriptaria m usando a chave p�blica $e_{E}$ de alguma entidade $E$ tentando personificar $B$, e $m$ seria recuper�vel por $E$.

\subsection{Irretratabilidade}

Esquemas de assinatura digital podem ser desenvolvidos para autentica��o da origem e integridade dos dados, e para facilitar o fornecimento de servi�os de irretratabilidade. Uma entidade $A$ usaria o algoritmo de gera��o de assinatura $SIGN$ de um esquema de assinatura digital e sua chave privada $d_{A}$ para computar a assinatura da mensagem: $s = SIGN_{d_{A}}(m)$. Ao receber $m$ e $s$, uma entidade $B$ que tem uma c�pia autentica da chave p�blica de $A$ $e_{A}$ usa um algoritmo de assinatura de verifica��o para confirmar que $s$ foi de fato gerado a partir de $m$ e $d_{A}$. Uma vez que $d_{A}$ � presumivelmente conhecido por $A$, $B$ est� seguro de que a mensagem foi realmente originada por $A$. Ademais, uma vez que a verifica��o requer apenas quantidades n�o secretas $m$ e $e_{A}$, a assinatura $s$ para $m$ pode tamb�m ser verificada por uma terceira parte que poderia estabelecer contesta��es se $A$ negar ter assinado a mensagem $m$. Diferente das assinaturas escritas � m�o, a assinatura $s$ de $A$ depende da mensagem $m$ sendo assinada, prevenindo um forjador de simplesmente acrescentar $s$ a uma mensagem $\tilde{m}$ linha e afirmar que $A$ assinou $\tilde{m}$. Mesmo embora n�o haja nenhuma necessidade de segredo com rela��o � chave p�blica $e_{A}$, � essencial que os verificadores usem uma c�pia aut�ntica de $e_{A}$ quando verificarem assinaturas geradas por $A$.

Deste modo, a criptografia de chave p�blica fornece solu��es elegantes para os tr�s problemas com criptografia de chave sim�trica: distribui��o de chaves, administra��o de chaves e suporte � irretratabilidade. Deve-se notar que embora necessidade de um canal secreto para distribui��o de chaves tenha sido eliminado, implementar uma infra-estrutura de chave p�blica (\emph{Public Key Infrastructure}, ou PKI) para distribuir e administrar chaves p�blicas pode ser um desafio formid�vel na pr�tica. Tamb�m, opera��es em chave p�blica em geral s�o significativamente mais lentas do que seus respectivos na criptografia de chave sim�trica. Portanto, sistemas h�bridos que se beneficiam da efici�ncia dos algoritmos de chave sim�trica e da funcionalidade dos algoritmos de chave p�blica s�o frequentemente usados.

Em um esquema de chave p�blica, um par de chaves � selecionado para que o problema de calcular a chave privada a partir da chave p�blica seja equivalente a resolver um problema computacional considerado intrat�vel. Os problemas te�ricos num�ricos cuja intratabilidade constr�i a base para a seguran�a dos esquemas comummente usados s�o:

\begin{itemize}
\item O problema da \textbf{fatora��o de inteiros}, cuja dificuldade � essencial para a seguran�a da encripta��o \emph{RSA} e esquemas de assinatura.
\item O problema do \textbf{logaritmo discreto}, cuja dificuldade � essencial para a seguran�a da encripta��o de chave p�blica \emph{ElGamal} e esquemas de assinatura e suas variantes tais como o \emph{Digital Signature Algorithm} (DSA).
\item O problema do \textbf{logaritmo discreto em curvas el�pticas}, cuja dificuldade � essencial para a seguran�a de todos os esquemas baseados em curvas el�pticas.\cite{menezes}
\end{itemize}

\section{Logaritmos Discretos}

\subsection{Problemas Baseados em Logaritmos Discretos}

O primeiro sistema baseado em logaritmo discreto foi o protocolo de troca de chaves proposto por Diffie e Hellman em 1976 \cite{diffie-hellman}. Em 1984, ElGamal descreveu a encripta��o de chave p�blica baseada no problema do logaritmo discreto e esquemas de assinatura \cite{elgamal}. Desde ent�o, muitas variantes destes esquemas foram propostas.


\subsection{Gera��o de chaves com Logaritmos Discretos}

Em sistemas de logaritmos discretos, um par de chaves est� associado com um conjunto de par�metros p�blicos do dom�nio $(p,q,g)$. Aqui, $p$ � um primo, $q$ � um divisor primo de $p-1$, e $g \in [1,p-1]$ tem ordem $q$ (i.e., $t=q$ � o menor inteiro positivo satisfazendo $g^{t} \equiv 1 \pmod p)$.
Uma chave privada � um inteiro x que � selecionado uniformemente de modo aleat�rio no intervalo $[1,q-1]$ (esta opera��o � denotada $x \in [1,q-1]$, e a chave p�blica correspondente � $y=g^{x}mod p$. O problema de determinar $x$ dados os par�metros do dom�nio $(p,q,g)$ e $y$ � o problema do logaritmo discreto (DLP).\cite{menezes}


\section{Curvas El�pticas}

\subsection{Hist�rico}
O estudo das curvas el�pticas por matem�ticos data da metade do s�culo XIX. Em 1984, Hendrik Lenstra\cite{lenstra} descreve um engenhoso algoritmo para fatorar inteiros que recai nas propriedades das curvas el�pticas. Esta descoberta motivou os pesquisadores a investigar novas aplica��es em criptografia sobre curvas el�pticas e teoria computacional dos n�meros.

A criptografia de chave p�blica foi concebida em 1976, mas sua primeira constru��o pr�tica se seguiu em 1977 quando Ron Rivest, Adi Shamir e Len Adleman propuseram o protocolo agora t�o conhecido RSA \cite{rsa} cuja seguran�a � baseada na intratabilidade do problema da fatora��o inteira. A criptografia baseada em curvas el�pticas (ECC) foi descoberta em 1985 por Neal Koblitz e Victor Miller.

Os protocolos de ECC s�o baseados em um problemas mais dif�cil de resolver que o do RSA, o ECDLP, sendo que os melhores algoritmos para resolv�-lo levam tempo exponencial frente ao tempo sub-exponencial para o RSA. Isso acarreta em um maior n�vel de seguran�a para chaves de menor tamanho comparativamente.

No fim dos anos 90, sistemas sobre curvas el�pticas come�aram a receber aceita��o comercial quando organiza��es de padr�es respeitadas especificaram protocolos sobre curvas el�pticas, e empresas privadas inclu�ram estes protocolos nos seus produtos de seguran�a. Hoje, ECC � considerado o estado-da-arte em criptografia de chave p�blica.

Os sistemas baseados em logaritmos discretos apresentados anteriormente podem ser descritos na configura��o de um grupo c�clico finito. A defini��o de grupos segue abaixo.

\subsection{Grupos}

Um grupo abeliano ($\G$,$*$) consiste de um conjunto $\G$ com uma opera��o bin�ria $* : \G \times \G \rightarrow \G$ satisfazendo as seguintes propriedades:
	(Associatividade) $a*(b*c) = (a*b)*c$ para todos os $a,b,c \in \G$
	(Exist�ncia de uma identidade) Existe um elemento $e \in \G$ tal que $a*e = e*a = a$ para todo $a \in \G$.
	(Exist�ncia de inversos) Para cada $a \in \G$, existe um elemento $b \in \G$, chamado inverso de $a$, tal que $a*b = b*a = e$.
	(Comutatividade) $a*b = b*a$ para todos $a,b \in \G$.


A opera��o do grupo � geralmente chamada de adi��o ($+$) ou multiplica��o ($*$). Em primeira inst�ncia, o grupo � chamado de grupo aditivo, o elemento (aditivo) identidade � normalmente denotado por $0$, e o inverso (aditivo) $d$ e $a$ � denotado por $-a$. Em uma segunda inst�ncia, o grupo � chamado de grupo multiplicativo, o elemento (multiplicativo) identidade � denotado por $1$ e o inverso (multiplicativo) de $a$ � denotado por $a^{-1}$ .
O grupo � finito se $\G$ � um conjunto finito, no caso em que o n�mero de elementos em $\G$ � chamado a ordem de $\G$.
Por exemplo, seja p um numero primo, e $F_{p} = {0,1,2,...,p-1}$ denota o conjunto dos inteiros m�dulo $p$. Ent�o $(F_{p},+)$, onde a opera��o $+$ � definida com a opera��o de adi��o de inteiros m�dulo $p$, � um grupo finito aditivo de ordem $p$ com elemento identidade (aditivo) $0$. Al�m isso, $(F^{*}_{p},\bullet)$, onde $F^{*}_{p}$ denota os elementos diferentes de zero em $F_{p}$ e a opera��o $\bullet$ � definida como a multiplica��o de inteiros m�dulo $p$, � um grupo finito multiplicativo de ordem $p-1$ com elemento identidade (multiplicativo) $1$. A tripla $(F_{p}, + , \bullet)$ � um corpo finito, denotado mais sucintamente por $F_{p}$.

Agora, se $\G$ � um grupo finito multiplicativo de ordem $n$ e $g \in \G$, ent�o o menor inteiro positivo $t$ tal que $gt = 1$ � chamado de ordem de $g$; esse $t$ sempre existe e � divisor de $n$. O conjunto $<g> = {gi : 0 \leq i \leq t-1}$ de todas as pot�ncias de $g$ � ele pr�prio um grupo sobre a mesma opera��o como $\G$, e � chamado um subgrupo c�clico de $\G$ gerado por $\G$. Declara��es an�logas s�o verdadeiras se $\G$ � escrito aditivamente. Assim, a ordem de $g \in \G$ � o menor divisor positivo $t$ de $n$ tal que $tg = 0$, e $<g> = {ig : 0 \leq i \leq t-1}$. Aqui, tg denota o elemento obtido por adicionar t c�pias de $g$. Se G tem um elemento $g$ de ordem $n$, ent�o $G$ � dito ser um grupo c�clico e $g$ � um gerador de $\G$. Por exemplo, com o os par�metros do DL $(p,q,g)$ definidos anteriormente, o grupo multiplicativo $(F^{*}_{p}, \bullet)$ � um grupo c�clico de ordem $p-1$. Ademais, $<g>$ � um subgrupo c�clico de ordem $q$.

\subsection{Grupos em Curvas El�pticas}

Seja $p$ um n�mero primo, e $F_{p}$ o corpo dos inteiros m�dulo $p$. Uma curva el�ptica $E$ sobre $F_{p}$ � definida por uma equa��o da forma 
\begin{equation}
\label{eq:defcurvaeliptica}
y^2= x^3+ ax+b
\end{equation}
onde $a$, $b$   $F_{p}$ satisfaz $4a^{3}+ 27b^{2}=0 (mod p)$. Um par $(x, y)$, onde $x, y \in F_{p}$, � um ponto na curva se $(x, y)$ satisfaz a equa��o \ref{eq:defcurvaeliptica}. O ponto no infinito, denotado por $\infty$, tamb�m � considerado estar contido na curva. O conjunto de todos os pontos sobre $E$ � denotado por $E(F_{p})$. Por exemplo, se $E$ � uma curva el�ptica sobre $F_{7}$ definida pela equa��o:

\begin{equation}
\label{eq:defcurvaeliptica2}
y^2= x^3+ 2x+4
\end{equation}

 Ent�o, os pontos sobre $E$ s�o:

$E(F_{7}) = { \infty, (0,2), (0,5), (1,0), (2,3), (2,4), (3,3), (3,4), (6,1), (6,6) }$.

Agora, h� um m�todo bem conhecido para somar 2 pontos numa curva el�ptica $P: (x_{1}, y_{1})$ e $Q: (x_{2}, y_{2})$ para produzir um terceiro ponto na curva $R: (x_{3}, y_{3})$, conforme ilustrado na Figura \ref{fig:somaeliptica} \cite{menezes}.

\begin{figure}[h]
	\centering
		\includegraphics[width=1.00\textwidth]{figuras/SomaEliptica.PNG}
	\caption{Soma em Curva El�ptica}
	\label{fig:somaeliptica}
\end{figure}

A regra de adi��o requer algumas opera��es aritm�ticas (adi��o, subtra��o, multiplica��o e invers�o) em $F_{p}$ com as coordenadas $x_{1}, y_{1}, x_{2}, y_{2}$. Com esta regra de adi��o, o conjunto dos pontos $E$ ($F_{p}$) forma um grupo abeliano (aditivo) com $\infty$ servindo como elemento neutro. Subgrupos c�clicos destes grupos sobre curvas el�pticas podem ser agora usados para implementar sistemas de logaritmos discretos.

\subsection{Gera��o de chaves em curva el�ptica}

Seja $E$ uma curva el�ptica definida sobre o corpo finito $F_{p}$. Seja $P$ um ponto em $E(F_{p})$, e suponha que $P$ tenha ordem prima $n$. Ent�o o subgrupo c�clico de $E(F_{p})$ gerado por $P$ � 

\begin{equation}
\label{eq:defcurvaeliptica3}
<P> = { \infty, P, 2P, 3P, ..., (n-1)P }.
\end{equation}

O primo $p$, a equa��o da curva el�ptica $E$, e o ponto $P$ e sua ordem $n$, s�o os par�metros p�blicos do dom�nio. Uma chave privada � um inteiro d que � selecionado uniformemente de forma aleat�ria no intervalo $[1,n-1]$, e a chave p�blica correspondente � $Q = d_{P}$.
O problema de determinar d dados os par�metros do dom�nio e $Q$ � o problema do logaritmo discreto em curvas el�pticas (ECDLP).

\section{Criptografia baseada em identidades e sistemas isentos de certificados}
%TOLERADO: arrumar
O conceito de criptografia baseada em identidades \cite{shamir} procura reduzir a dificuldade causada pela necessidade de manuten��o de uma infra-estrutura de chave p�blica, ou \emph{PKI}. Nesse tipo de sistema a chave p�blica do usu�rio pode ser arbitrariamente escolhida, e uma autoridade de confian�a gera sua chave privada. No entanto, a autoridade de confian�a tem o conhecimento de todas as chaves privadas e poderia recuperar as informa��es de qualquer usu�rio.

Os sistemas de seguran�a isentos de certificados (ou, em uma defini��o mais precisa, auto-certificados) \cite{al-riyami-paterson} foram concebidos com o objetivo de resolver o problema de comprometimento da chave de sistemas baseados em identidades. Nesses sistemas, a chave privada do usu�rio � composta por dois componentes: uma parcela baseada em identidades, e, desse modo, sujeita a comprometimento, e uma parcela convencional, por�m n�o certificada. Esse tipo de sistema combina as melhores caracter�sticas de sistemas baseados em identidades e em certificados, por�m continuam sendo de dif�cil especifica��o.

\section{Emparelhamentos}
%TOLERADO: arrumar
Os mapeamentos bilineares, ou emparelhamentos \cite{sakai-ohgishi-kasahara,boneh-franklin}, tornaram poss�vel o uso de criptografia baseada em identidades na pr�tica. Emparelhamentos s�o formalmente definidos como se segue. Seja $k$ um par�metro de seguran�a e $n$ um n�mero primo de  $k$ \emph{bits}. Sejam $\G_1$, $\G_2$ e $\G_T$ grupos de ordem $n$. Dizemos que $(\G_1,\G_2,\G_T)$ s�o grupos de emparelhamento se existe um mapeamento bilinear $e: \G_1 \times \G_2 \rightarrow \G_T$ que satisfa�a �s propriedades:
\begin{enumerate}
\item Bilinearidade: $\forall (S,T) \in \G_1 \times \G_2$, $\forall a,b \in \Z_n$, $e(aS, bT) = e(S,T)^{ab}$.
\item N�o-degenerabilidade: $\forall S \in \G_1$, $e(S,T)=1$ para todo $T \in \G_2$ se e somente se $S=\mathcal{O}_{\G_1}$.
\item Computabilidade: $\forall (S,T) \in \G_1 \times \G_2$, $e(S,T)$ � eficientemente comput�vel.
\end{enumerate}

\section{BLMQ}
%DONE arrumar
Nesta se��o apresentamos caracter�sticas b�sicas e defini��es do BLMQ ~\cite{barreto-libert-mccullagh-quisquater}, um esquema de criptografia baseado em identidades. O esquema � composto pelos seguintes algoritmos:

\begin{itemize}

\item \textbf{Setup:} dado um par�metro de seguran�a $k$, este algoritmo escolhe um n�mero primo de $k$ bits $n$, grupos de mapeamento bilinear $(\G_1,\G_2,\G_T)$  de ordem $n$ que suportam um emparelhamento eficientemente comput�vel e n�o degenerado $e: \G_1 \times \G_2 \rightarrow \G_T$, geradores $P \in \G_1$, $Q \in \G_2$ e as fun��es de hash $h_0: \G_T \times \{0, 1\}^\ast \rightarrow \Z_n^\ast$,
$h_1: \{0, 1\}^\ast \rightarrow \Z_n^\ast$.
Uma chave mestra $s \samples \Z_n^\ast$ � tamb�m escolhida, para a qual a seguinte chave publica $P_{pub} = sP \in \G_1$ � associada. O gerador $g = e(P, Q) \in \G_T$ � tamb�m inclu�do entre os par�metros p�blicos que s�o $\texttt{params} = (k, n, \G_1, \G_2, \G_T, P, Q, g, P_{pub}, e, h_0, h_1)$.

\item \textbf{Private-Key-Extract:} Toma como entrada o identificador $\ID_A \in \{0, 1\}^\ast$ da entidade $A$ e extrai a chave privada baseada em identidades $Q_A \gets (h_1(\ID_A) + s)^{-1}Q \in \G_2$ de $A$. A entidade $A$ pode verificar a consist�ncia dessa chave verificando que $e(h_1(\ID_A) P + P_{pub}, Q_A) = g$. Esta configura��o � chamada de estilo Sakai-Kasahara~\cite{sakai-kasahara}.

\item \textbf{Sign:} Para assinar $m \in \{0, 1\}^\ast$ sob a chave privada  $P_A$, o assinante toma $u \samples \Z_n^\ast$ e calcula
\begin{enumerate}
\item $r \gets g^u$
\item $h \gets h_0(r, m)$
\item $S \gets (u - h) Q_A$
\end{enumerate}
A mensagem assinada � a tripla $(m, h, S) \in \{0, 1\}^\ast \times \Z_n^\ast \times \G_2$.

\item \textbf{Verify:} dada um identidade $\ID_A$, sob a recep��o de $(m, h, S)$ o verificador
\begin{enumerate}
\item $r \gets e(h_1(\ID_A) P + P_{pub}) g^h$
\item $v \gets h_0(r, m)$
\end{enumerate}
O verificador aceita a mensagem assinada se e somente se $v = h$.

\end{itemize}

Pode-se mostrar que esse esquema � existencialmente infalsific�vel sob ataques de mensagens adaptativamente escolhidas (EUF-IBS-CMA abreviados) no modelo do or�culo aleat�rio sob a assun��o do $q$-SDHP \cite[section~3.1]{barreto-libert-mccullagh-quisquater}. Perceba que nesta descri��o escolhemos definir $P_{pub} \in \G_1$, $Q_A \in \G_2$ para evitar a aritm�tica em $\G_2$, mas uma descri��o an�loga com $Q_{pub} \in \G_2$, $P_A \in \G_1$ e mensagens assinadas em $\{0, 1\}^\ast \times \Z_n^\ast \times \G_1$ seria igualmente segura, enquanto mantemos a assinatura t�o curta quanto poss�vel na pr�tica.

\section{BDCPS}

O protocolo de seguran�a BDCPS \cite{bdcps} integra as assinaturas baseadas em identidades do BLMQ, assinaturas de Schnorr \cite{schnorr} e a cifrassinatura de Zheng \cite{zheng} em um esquema isento de certificados conforme proposto por \cite{al-riyami-paterson}. Este protocolo foi criado especialmente para atender �s necessidades deste projeto.

O protocolo � composto pelos seguintes algoritmos:
\begin{itemize}

\item \textbf{Setup:} Algoritmo gerador do conjunto dos par�metros p�blicos necess�rios. 
O algoritmo escolhe um par�metro de seguran�a $k$ e define:

$n:$  Um inteiro primo de k bits. 

$(\G_1,\G_2,\G_T)$ Grupos de mapeamento bilinear de ordem $n$  

$e: \G_1 \times \G_2 \rightarrow \G_T$: Emparelhamento eficientemente comput�vel e n�o-degradado.

$P \in \G_1$, $Q \in \G_2$: Os pontos geradores dos grupos $\G_1$ e $\G_2$ respectivamente.

Resumos criptogr�ficos \emph{(hashes)} 

$h_0: \G_T^2 \times \{0, 1\}^\ast \rightarrow \Z_n^\ast$,

$h_1: \G_T \times \{0, 1\}^\ast \rightarrow \Z_n^\ast$, % id hash

$h_2: \G_T \rightarrow \{0, 1\}^\ast$, % msg encryption hash

$h_3: (\G_T \times \{0, 1\}^\ast)^3 \rightarrow \Z_n^\ast$. % msg auth hash

Uma chave mestra $s \stackrel{R}{\gets} \Z_n^\ast$ tamb�m � escolhida, � qual a chave p�blica 
$P_{pub} = sP \in \G_1$ � associada. 

O gerador $g = e(P, Q) \in \G_T$ tamb�m � incluso entre os par�metros p�blicos do sistema, $\texttt{params} = (k, n, \G_1, \G_2, \G_T, e, P, Q, g, P_{pub}, h_0, h_1, h_2, h_3)$.


\item \textbf{Set-Secret-Value:} dados $\texttt{params}$, o algoritmo toma $x_A \stackrel{R}{\gets} \Z_n^\ast$ como o valor secreto da identidade $A$. O usu�rio $A$ pode definir $x_A$, sua chave parcial privada, independente do algoritmo e, neste caso, ser� usada como uma senha comum.

\item \textbf{Set-Public-Value:} dado o valor secreto $x_A \in \Z_n^\ast$ da identidade $A$, computa $y_A \gets g^{x_A} \in \G_T$ como o valor p�blico de $A$.

\item \textbf{Private-Key-Extract:} Obt�m $\ID_A \in \{0, 1\}^\ast$, o identificador de $A$  e  o valor p�blico $y_A \in \G_T$, e calcula a chave privada baseada em identidade de $A$, $Q_A \gets (h_1(y_A, \ID_A) + s)^{-1}Q \in \G_2$. A entidade $A$ consegue verificar a consist�ncia desta chave verificando se $e(h_1(y_A, \ID_A)P + P_{pub}, Q_A) = g$. Esta configura��o � denominada estilo de chave Sakai-Kasahara ~\cite{sakai-kasahara}.

\item \textbf{Set-Private-Key:} dada a chave privada parcial da entidade $A$, $Q_A \in \G_2$ e o valor secreto $x_A \in \Z_n^\ast$, este algoritmo estabelece o par $(x_A, Q_A) \in \Z_n^\ast \times \G_2$ como o par completo da chave privada de $A$.

\item \textbf{Set-Public-Key:} dada a chave privada parcial de $A$, $Q_A \in \G_2$, o valor secreto $x_A \in \Z_n^\ast$, e o correspondente valor p�blico $y_A \in \G_T$, o assinante toma $u_A \stackrel{R}{\gets} \Z_n^\ast$ e calcula
\begin{enumerate}
\item $r_A \gets g^{u_A}$
\item $h_A \gets h_0(r_A, y_A, \ID_A)$
\item $T_A \gets (u_A - x_A h_A) Q_A$
\end{enumerate}
A chave p�blica completa da entidade $A$ � a tripla $(y_A, h_A, T_A) \in \G_T \times \Z_n^\ast \times \G_2$. Este configura��o � uma combina��o da assinatura de Schnorr (sob a chave $x_A$) com a assinatura BLMQ (sob a chave $Q_A$) no valor p�blico $y_A$ e a identidade $\ID_A$. 
% Na d�vida, comentei isso. Seria melhor se tiv�ssemos refer�ncias (de FAPIP, DLP)
% O dif�cil problema da falsifica��o de tal assinatura � o FAPIP em vez do DLP como em Schnorr; em outras palavras, ele consiste em calcular $Q_A' := x_A Q_A$ dados $y_A := g^{x_A}$ e $P_A' := h_1(y_A, \ID_A)P + P_{pub}$. Perceba-se que � f�cil calcular $y_A$ dados $Q_A'$ e $P_A'$, uma vez que equivale a calcular $e(P_A', Q_A')$ (e verificando que $P_A' = h_1(e(P_A', Q_A'), \ID_A)P + P_{pub}$).

\item \textbf{Public-Key-Validate:} dada a chave p�blica completa da entidade $A$, $(y_A, h_A, T_A)$, este algoritmo verifica que $y_A$ tem ordem $n$ (i.e. que $y_A \neq 1$ mas $y_A^n = 1$) e calcula
\begin{enumerate}
\item $r_A \gets e(h_1(y_A, \ID_A)P + P_{pub}, T_A) y_A^{h_A}$
\item $v_A \gets h_0(r_A, y_A, \ID_A)$
\end{enumerate}
O verificador aceita a mensagem se, e somente se $v_A = h_A$. O processo de valida��o combina a verifica��o da assinatura Schnorr com a verifica��o da assinatura BLMQ.

\item \textbf{Signcrypt:} Para encriptar $m \in \{0, 1\}^\ast$ sob a chave p�blica do receptor $y_B \in \G_T$ previamente validade para a identidade $\ID_B$ e $P_{pub}$, e a chave privada do emissor $x_A \in \Z_n^\ast$, chave p�blica $y_A \in \G_T$ e a identidade $\ID_A$, o emissor toma $u \stackrel{R}{\gets} \Z_n^\ast$ e calcula
\begin{enumerate}
\item $r \gets y_B^u$
\item $c \gets h_2(r) \oplus m$
\item $h \gets h_3(r, m, y_A, \ID_A, y_B, \ID_B)$ \label{eq:auth}
\item $z \gets u - x_A h$ \label{eq:sign}
\end{enumerate}
O criptograma de assinatura � a tripla $(c, h, z) \in \{0, 1\}^\ast \times \Z_n^2$. Comparado ao m�todo de cifrassinatura de Zheng, as identidades de ambos o emissor e o destinat�rio s�o inclusas na equa��o de autentica��o~\ref{eq:auth}, e a equa��o de assinatura~\ref{eq:sign} segue o estilo Schnorr em vez do dedicado, por�m levemente mais complicado(devido � presen�a da invers�o de corpos), estilo Zheng, similar ao DSA ~\cite{nist-fips-186-2}.

\item \textbf{Unsigncrypt:} dada a chave p�blica do emissor $y_A \in \G_T$ previamente validade para a identidade $\ID_A$ e $P_{pub}$, e a chave privada do receptor $x_B \in \Z_n^\ast$, a chave p�blica $y_B \in \G_T$ e a identidade $\ID_B$, sob a recep��o da tripla $(c, h, z)$ o receptor verifica se $h, z \in \Z_n^\ast$ e calcula
\begin{enumerate}
\item $r \gets y_A^{h x_B} y_B^z$ \label{eq:nonce-rec}
\item $m \gets h_2(r) \oplus c$
\item $v \gets h_3(r, m, y_A, \ID_A, y_B, \ID_B)$
\end{enumerate}
O receptor aceita a mensagem se, e somente se, $v = h$. A equa��o \ref{eq:nonce-rec} � levemente mais simples que seu correlato em Zheng devido ao estilo Schnorr adotado para a cifrassinatura.

\end{itemize}

\chapter{Discuss�o}

\section{Escopo}
%Falar aqui exatamente o que o sistema faz e o que ele n�o faz! Falar de problemas que existem, mas que ficam fora do nosso escopo.
O software a ser desenvolvido ser� designado por "Sistema de SMS Seguro". O objetivo do software � prover uma camada de seguran�a a n�vel de aplica��o para mensagens SMS em redes de telefonia m�vel. O software dever� fornecer servi�os b�sicos de seguran�a, a saber, confidencialidade, integridade e autenticidade �s mensagens SMS, permitindo ao usu�rio assinar, cifrar, decifrar e verificar mensagens enviadas pela rede GSM. As solu��es adotadas no projeto envolvem criptografia de chave p�blica, criptografia baseada em identidade e tamb�m esquemas auto-certificados, conforme definidos no cap�tulo anterior. A ado��o dessa combina��o deve dispensar a exist�ncia de um diret�rio de chaves p�blicas, uma vez que o uso de certificados convencionais exigiria uma infra-estrutura e demandaria um consumo de banda impratic�veis em uma rede de telefonia celular com SMS.

O software ser� aplic�vel em �reas que requeiram seguran�a da informa��o que trafega nas redes de telefonia m�vel. Alguns exemplos s�o aplica��es militares, banc�rias, comunica��o pessoal sigilosa e com�rcio eletr�nico. Os principais benef�cios do sistema s�o a sua flexibilidade, podendo ser adaptado �s necessidades dos clientes, e leveza, j� que sua arquitetura � restrita � camada de aplica��o: o software opera sobre a camada de aplica��o do modelo OSI \cite{osi}, sendo transparente � arquitetura interna da rede GSM. Essas duas qualidades tornam poss�vel sua viabilidade em diversos cen�rios.

O \emph{Sistema de SMS Seguro} n�o � respons�vel por garantir a confiabilidade e disponibilidade de entrega das mensagens. Essa fun��o � de responsabilidade do fornecedor do servi�o m�vel.
O sistema tamb�m n�o garante prote��o quanto � clonagem do telefone, mas pode garantir a autenticidade do emissor e indiretamente detectar a clonagem caso o usu�rio j� tenha se cadastrado na autoridade de confian�a.

O sistema tamb�m n�o oferece o servi�o de irretratabilidade, uma vez que a chave privada do receptor � utilizada no processo de verifica��o de autenticidade da mensagem. Desse modo, um usu�rio $B$ n�o pode convencer um terceiro de que uma mensagem foi enviada por $A$ sem comprometer sua chave privada.

\section{M�tricas e Restri��es}

A seguir, definimos as m�tricas e restri��es do sistema. % e suas limita��es.

\begin{itemize}

\item Tempo de espera: Consiste nos tempos para cifrassinar e vericifrar uma mensagem. Baseando-se em aplica��es j� existentes e satisfazendo os requisitos de usabilidade de nosso projeto, estimamos que um intervalo de espera para processamento de uma mensagem de no m�ximo 5 segundos seja toler�vel pelo usu�rio.

\item Tamanho m�ximo de mensagens do protocolo: Consiste no n�mero de bytes ocupados por dados de controle do algoritmo. Estabelecemos que este \emph{overhead} n�o deve ultrapassar 25\% do espa�o total da mensagem.

\item Tamanho das chaves privada/p�blica: Devido �s limita��es de banda, estabeleceu-se que cada o tamanho chave usada n�o dever� exceder 200 bits. No entanto, essa restri��o n�o deve comprometer o n�vel de seguran�a desejado.

\item Tamanho do certificado: Devido �s limita��es de banda, estabeleceu-se que o tamanho do certificado de uma chave n�o dever� exceder 512 bits. Desejamos poder transferir o certificado em um �nico SMS, sem comprometer o espa�o necess�rio para o \emph{overhead} do protocolo.

\item Celular desbloqueado: Para que o sistema execute no ambiente do celular ele deve estar desbloqueado para execu��o de aplicativos Java.

\item Interface de troca de dados: o celular dever� possui alguma interface para poder fazer o \emph{download} do aplicativo.


\end{itemize}

%TOLERADO: aqui ta tudo igual ao paper... alterar, enriquecer!

Um certificado digital t�pico ocupa entre 2KB e 4KB, e uma solu��o baseada em infra-estrutura convencional de chaves p�blicas inviabilizaria completamente o sistema: antes de se enviar uma mensagem SMS segura para algum usu�rio, seria necess�rio receber o certificado desse usu�rio particionado em 15 a 30 mensagens SMS, al�m de enviar em resposta outro certificado em mais 15 a 30 mensagens SMS. Esse esfor�o precisaria ser efetuado novamente para cada novo destinat�rio a quem determinado usu�rio desejasse enviar mensagens. Some-se a isto o espa�o ocupado por uma �nica assinatura convencional, tipicamente de 128 bytes por estar baseada no algoritmo RSA com 1024 bits; este \emph{overhead} seria duplicado com o requisito de cifrar e assinar a mensagem, isto �, tomaria 256 bytes do espa�o dispon�vel. 

Por outro lado, a manuten��o de um diret�rio confi�vel de chaves p�blicas, t�pico de sistemas de criptografia convencionais, seria impratic�vel em uma rede de telefonia celular.  Uma solu��o tecnol�gica baseada em alternativas � criptografia convencional �, portanto, imprescind�vel. Sendo assim, foi considerado o uso de criptografia em curvas el�pticas com assinatura baseada em identidades. Aprofundando-se na especifica��o, percebeu-se ainda que a chave p�blica do usu�rio poderia ser estabelecida essencialmente a partir de sua identifica��o �nica no sistema, ou seja, seu pr�prio n�mero de celular. Desse modo, a criptografia em curvas el�pticas baseada em identidades com emparelhamentos bilineares parecia, inicialmente, ser capaz de atender aos requisitos do sistema.

\chapter{An�lise de requisitos do sistema}

\section{Requisitos funcionais}

 Ap�s a an�lise do escopo e das restri��es do sistema, foram levantados os seguintes requisitos funcionais:
 
\subsection{Cifrassinatura de mensagem}
\textbf{Introdu��o/Prop�sito} O sistema dever� fornecer servi�o de confidencialidade atrav�s da funcionalidade de cifrassinatura das mensagens SMS, ou seja, as mensagens, para trafegar na rede GSM dever�o estar encriptadas e assinadas.

\textbf{Est�mulo/Resposta} O est�mulo neste caso prov�m do usu�rio ao requisitar o servi�o de cifrassinatura e a resposta do sistema � realizar o servi�o enviando a mensagem cifrassinada.

\subsection{Vericifra��o de mensagem}
\textbf{Introdu��o/Prop�sito} O sistema dever� fornecer ao usu�rio o servi�o de ele poder verificar o autor de uma mensagem recebida como o de ler seu conte�do.

\textbf{Est�mulo/Resposta} O usu�rio requisita ao sistema a vericifra��o de uma determinada mensagem e o sistema processa a mensagem devolvendo a veracidade de sua validade e seu conte�do.

\subsection{Envio de mensagem}
\textbf{Introdu��o/Prop�sito}: O sistema deve fornecer ao usu�rio o servi�o de envio de uma mensagem para o destinat�rio desejado.
	
\textbf{Est�mulo/Resposta}: Usu�rio deseja enviar uma mensagem SMS criptografada e requisita o servi�o ao sistema que efetua o envio.


\subsection{Gera��o de chave privada}
\textbf{Introdu��o/Prop�sito}: O sistema deve fornecer para um novo usu�rio o servi�o gerar sua chave privada e entreg�-lo de forma segura. O Key Generation Bureau possui essa responsabilidade.
	
\textbf{Est�mulo/Resposta}: Novo usu�rio requisita ao sistema a gera��o de sua chave privada. A requisi��o chega at� o KGB que gera a chave privada do usu�rio
 e a retorna por meio de uma mensagem segura.

\section{Requisitos n�o-funcionais}
\subsection{Usabilidade}
O tamanho da chave privada n�o deve prejudicar a usabilidade do software. O m�todo de entrada das mensagens deve ser semelhante ao dos aparelhos celulares convencionais.
\subsection{Desempenho}
A aplica��o deve ser capaz de cifrar ou decifrar uma mensagem em menos de 5 segundos.
\subsection{Confiabilidade}
O software dever� apresentar \emph{MTTF} de 1 ano. Entende-se como falha a parada do software pela subida de uma exce��o n�o tratada. Essa medida ignora falhas de componentes externos ao software (hardware do celular, plataforma Java).
\subsection{Disponibilidade}
O software dever� apresentar disponibilidade de 99\%. Entende-se como disponibilidade a raz�o entre as tentativas bem sucedidas de acessar o software e o total de tentativas. Ou seja, a cada 100 tentativas de acessar o software apenas uma n�o ter� sucesso.
\subsection{Compatibilidade}
O software dever� ser compat�vel com todos os dispositivos celulares equipados com a plataforma Java ME (Micro Edition), desde que estejam desbloqueados, e com a configura��o CLDC.
\subsection{Portabilidade}
O software dever� ser port�vel para a plataforma Java SE (Standard Edition) tendo em vista o uso da aplica��o como interface com web services.
\subsection{Seguran�a}
O software deve garantir que o destinat�rio da mensagem e apenas ele, al�m do remetente, tenha acesso ao seu conte�do em tempo vi�vel. O software tamb�m deve garantir a integridade da mensagem em rela��o a corrup��es maliciosas ou acidentais durante o tr�fego.

\section{Casos de uso}

O sistema possui 3 atores, a saber
\begin{enumerate}
	\item \textbf{Usu�rio:} o usu�rio do sistema m�vel pessoal que enviar� e receber� mensagens atrav�s do canal seguro.
	\item \textbf{KGB:} � a autoridade de seguran�a, respons�vel por gerar a parcela da chave privada baseada em identidades dos usu�rios.
	\item \textbf{Sistema:} o sistema dever� acionar-se sempre que uma mensagem SMS chegar ao \emph{listener} da porta especificada.
\end{enumerate}

Nas se��es abaixo detalharemos cada caso de uso do sistema, representados sucintamente no diagrama da Figura \ref{fig:usecase_diagrama}.

\begin{figure}[h]
	\centering
		\includegraphics[width=1.00\textwidth]{figuras/usecase_diagram.PNG}
	\caption{Diagrama de casos de uso do sistema}
	\label{fig:usecase_diagrama}
\end{figure}

\subsection{Cadastrar-se no sistema}
	 \begin{enumerate} 
	 \item \textbf{Descri��o:} Novo usu�rio deseja usar o sistema pela primeira vez e precisa efetuar as configura��es necess�rias para poder receber sua chave privada.
   \item \textbf{Evento Iniciador:} Usu�rio seleciona a op��o de primeiro uso do sistema
	 \item \textbf{Atores:} Usu�rio, KGB.
	 \item \textbf{Pr�-condi��o:} Sistema de SMS seguro apresentando sua tela inicial.
	 \item \textbf{Seq��ncia de Eventos:} 
	 \begin{enumerate}
			\item Usu�rio seleciona o bot�o de primeiro uso.
			\item Sistema pede a entrada de uma nova senha privada do usu�rio.
			\item Usu�rio cadastra uma nova senha no sistema e confirma.
			\item Sistema exibe notifica��o de envio de mensagem de controle para a KGB.
			\item Usu�rio confirma o envio e sistema transmite a mensagem.
			\item Ao receber a mensagem, a KGB gera a chave privada do usu�rio e retorna uma mensagem segura contendo a chave gerada.
			\item O sistema do usu�rio recebe a mensagem da KGB contendo sua chave privada.
			\item Sistema pede novamente a senha do usu�rio e extrai a chave privada do usu�rio
			\item O sistema verifica se a chave privada recebida � v�lida.
			\item O sistema armazena a nova chave no celular.
		\end{enumerate}
		\item \textbf{P�s-Condi��o:} Sistema volta para a tela inicial e usu�rio est� apto a autenticar novos contatos para trocar mensagens.
		\item \textbf{Extens�es:} 
		\begin{enumerate}
		\item Caso haja algum problema na gera��o ou na mensagem que cont�m a chave privada do usu�rio ou ainda se outra entidade tentou se passar por KGB ent�o o sistema exibe mensagem de chave inv�lida ao usu�rio.
		\end{enumerate}
\end{enumerate}
		
\subsection{Autenticar novo contato}
		\begin{enumerate}
		\item \textbf{Descri��o:} Quando um usu�rio quiser trocar mensagem com um contato que ainda n�o foi autenticado pelo Sistema de SMS Seguro dever� requisitar sua autentica��o.
		\item \textbf{Evento Iniciador:} Usu�rio deseja autenticar um novo contato para envi�-lo uma mensagem.
		\item \textbf{Atores:} Usu�rio que quer se comunicar, usu�rio recebedor da mensagem.
		\item \textbf{Pr�-condi��o:} Sistema exibe tela inicial.
		\item \textbf{Seq��ncia de Eventos:} 
		\begin{enumerate}
			\item Usu�rio seleciona a op��o de autenticar novo contato.
			\item Usu�rio insere o n�mero do telefone do novo contato e seleciona \emph{OK}.
			\item Sistema exibe notifica��o de envio de SMS para o contato informado.
			\item Usu�rio confirma o envio da mensagem SMS.
			\item Sistema envia requisi��o de autentica��o para o novo contato.
		\end{enumerate}
    \item \textbf{P�s-Condi��o:} Sistema volta para a tela inicial.
		\item \textbf{Extens�es:} 
		\begin{enumerate}
			\item Sistema exibe notifica��o de erro no envio da mensagem caso o servi�o de envio esteja indispon�vel. (Passo v).
		\end{enumerate}
		\end{enumerate}
	
\subsection{Enviar Mensagem}
  	\begin{enumerate}
  	\item \textbf{Descri��o:} Usu�rio deseja compor e enviar uma nova mensagem SMS para outro usu�rio.
  	\item \textbf{Evento Iniciador:} Usu�rio seleciona bot�o de envio de nova mensagem.
  	\item \textbf{Atores:} Usu�rio emissor da mensagem.
  	\item \textbf{Pr�-condi��o:} Sistema de SMS seguro apresentando sua tela inicial.
  	\item \textbf{Seq��ncia de Eventos:} 
  	\begin{enumerate}
  	\item Usu�rio emissor da mensagem seleciona bot�o de envio de mensagem. 
		\item Sistema exige que o usu�rio indique o destinat�rio da mensagem.
		\item Usu�rio seleciona o destino da lista de contatos exibida.
		\item Usu�rio comp�e a mensagem a ser enviada
		\item	Usu�rio confirma o envio da mensagem para o destinat�rio escolhido.
		\item Sistema exibe notifica��o de envio da mensagem.
		\end{enumerate}
	  \item \textbf{P�s-Condi��o:} A notifica��o de mensagem enviada � exibida e o sistema retorna � tela inicial.
		\item \textbf{Extens�es:} 
		\begin{enumerate}
		\item Sistema exibe notifica��o de erro no envio da mensagem caso o servi�o de envio esteja indispon�vel. (Passo v).
		\end{enumerate}
		\item \textbf{Inclus�es:}
		\begin{enumerate}
		\item Sistema busca todos os contatos da lista de contatos do celular para exibi-los.
		\item	Caso de uso 4.
		\end{enumerate}
		\end{enumerate}

\subsection{Recep��o de Mensagem}
	\begin{enumerate}
	\item \textbf{Descri��o:} Quando uma nova mensagem chega no celular o sistema deve capt�-la e fazer seu tratamento.
	\item \textbf{Evento Iniciador:} Chega uma nova mensagem do Sistema de SMS Seguro no celular de um usu�rio.
	\item \textbf{Atores:} Sistema operacional.
	\item \textbf{Pr�-condi��o:} Celular do usu�rio ligado.
	\item \textbf{Seq��ncia de Eventos:}
	\begin{enumerate}
	\item Celular recebe a nova mensagem e a coloca na fila.
	\item	Sistema operacional do celular capta a mensagem e requisita ao usu�rio que inicialize a aplica��o caso ela n�o esteja em execu��o.
	\item	O sistema identifica a primitiva da mensagem e trata de forma correspondente.
	\end{enumerate}
	\item \textbf{P�s-Condi��o:} a mensagem est� processada e o sistema est� exibindo a tela inicial.
	\item \textbf{Extens�es:} 
	\begin{enumerate}
	\item	Sistema trata mensagem cifrada e assinada. (Passo iii)
	\item	Sistema trata mensagem de autentica��o de usu�rio.(Passo iii)
	\item	Sistema trata mensagem de pedido da chave privada. (Passo iii)
	\item	Sistema trata mensagem de entrega de chave privada. (Passo iii)
	\end{enumerate}
\end{enumerate}

\subsection{Encriptar/Assinar Mensagem}
		\begin{enumerate}
		\item \textbf{Descri��o:} Usu�rio escreveu uma mensagem para algu�m e deseja cifr�-la e assin�-la.
		\item \textbf{Evento Iniciador:} Usu�rio requisita envio de mensagem cifrada e assinada ao sistema.
		\item \textbf{Atores:} Usu�rio que deseja enviar uma mensagem segura.
		\item \textbf{Pr�-condi��o:} Usu�rio est� com a mensagem pronta na tela de envio.
		\item \textbf{Seq��ncia de Eventos:}
		\begin{enumerate}
		\item	Usu�rio seleciona a op��o de enviar a mensagem.
		\item	Sistema cifra e assina a mensagem e exibe tela de confirma��o de envio.
		\item	Usu�rio confirma o envio e sistema transmite a mensagem segura.
		\end{enumerate}
		\item \textbf{P�s-Condi��o:} Sistema volta para a tela inicial.
		\end{enumerate}

\subsection{Decriptar/Verificar Mensagem}
  	\begin{enumerate}
  	\item \textbf{Descri��o:} Usu�rio deseja visualizar uma mensagem na sua caixa de entrada.
		\item \textbf{Evento Iniciador:} Usu�rio abre a caixa de entrada do sistema.
		\item \textbf{Atores:} Usu�rio.
		\item \textbf{Pr�-condi��o:} Sistema de SMS seguro apresentando mensagens recebidas na caixa de entrada.
		Sequ�ncia de Eventos: 
		\begin{enumerate}
		\item	Usu�rio escolhe a mensagem que deseja visualizar e seleciona ok.
		\item	Sistema verifica e decifra a mensagem.
		\item	Sistema exibe a mensagem clara para que o usu�rio possa l�-la.
		\end{enumerate}
		\item \textbf{P�s-Condi��o:} Sistema exibindo mensagem clara para o usu�rio.
		\end{enumerate}


\chapter{Escolha do esquema criptogr�fico}

\section{Por que criptografia em curvas el�pticas?}

H� v�rios crit�rios que precisam ser considerados ao selecionar-se uma fam�lia de esquemas de chave p�blica para uma determinada aplica��o.

Os princ�pios s�o:
\begin{itemize}
\item Funcionalidade. A fam�lia de chave p�blica fornece as habilidades desejadas?
\item Seguran�a. O que garante que os protocolos s�o seguros?
\item Efici�ncia. Para o n�vel de seguran�a desejado, os protocolos fornecem os objetivos de efici�ncia.
\end{itemize}

Outros fatores que podem influenciar uma decis�o incluem a exist�ncia de padr�es de melhores pr�ticas desenvolvidos por organiza��es de padroniza��o confi�veis, a disponibilidade de produtos criptogr�ficos comerciais, coberturas de patentes, e extens�o das aplica��es existentes.

As fam�lias do RSA, do logaritmo discreto e das curvas el�pticas introduziram na criptografia de chave p�blica todas as funcionalidades b�sicas esperadas - encripta��o, assinaturas e troca de chaves.

Durante os anos, pesquisadores desenvolveram t�cnicas para modelar e provar a seguran�a dos protocolos RSA, logaritmo discreto e curvas el�pticas sob hip�teses razo�veis. A quest�o fundamental da seguran�a que permanece � a dificuldade do problema matem�tico subjacente que � necess�rio para a seguran�a de todos os protocolos em uma fam�lia de chave p�blica - o problema da fatora��o inteira para sistemas RSA, o problema do logaritmo discreto para os sistemas baseados em logaritmos discretos e o problema de logaritmo discreto em curvas el�pticas em sistemas baseados em curvas el�pticas. A dificuldade percebida desses problemas impacta diretamente na efici�ncia uma vez que ela dita os tamanhos do dom�nio e dos par�metros das chaves. Isso, por outro lado, afeta a efici�ncia das opera��es aritm�ticas subjacentes.

%TODO: Eu (Eduardo) colei aqui esse texto. Talvez reformular.. Deve ter informa��o repetida acima.
Dado que o tempo de uso do RSA de 1024 bits est� no fim, uma nova vers�o ser� necess�ria \cite{rsalabs}. Contudo, para um aumento no n�vel de seguran�a do RSA, � preciso aumentar consideravelmente o tamanho das chaves, uma vez que a rela��o entre o tamanho das chaves e o n�vel de seguran�a � exponencial, a chave cresce muito rapidamente quando aumenta-se o n�vel de seguran�a desejado.\cite{menezes} %TODO TODO TODO: colocar a f�rmula, � exponencial? citar ref...

Em paralelo, um aumento equivalente no n�vel de seguran�a de criptografia em curvas el�pticas acarreta menor aumento no tamanho das chaves. Este fato ocorre devido � rela��o entre o n�vel de seguran�a de criptografia em curvas el�pticas e o tamanho das chaves, que � uma rela��o diretamente proporcional (cresce linearmente). Para uma chave $k$, tem-se um n�vel de segura�a de aproximadamente $k/2$. \cite{menezes}%TODO: citar algo! Colocar a f�rmula... � 2^k/2 ? Acho que isso � s� uma aproxima��o... Citar ref..

%Explicar aqui que analisamos os seguintes candidatos:
\section{BLMQ}

A primeira tentativa de solu��o adotava o esquema de cifrassinatura baseada em identidades BLMQ ~\cite{barreto-libert-mccullagh-quisquater}. Trata-se de um esquema de criptografia baseada em identidades.

O esquema foi escolhido por, aparentemente, atender aos requisitos estabelecidos. O BLMQ era notadamente mais eficiente que esquemas de criptografia baseada em identidades anteriores, como o de Boneh-Franklin \cite{boneh-franklin}, o que poderia tornar, pela primeira vez, o uso desse tipo de criptografia vi�vel em ambientes m�veis como a telefonia celular. Al�m disso, o uso de uma assinatura de 160 bits garantiria um n�vel de seguran�a equivalente ao do RSA de 1024 bits \cite{rsalabs}, maximizando o espa�o �til da mensagem.

\subsection{Testes de viabilidade}

O esquema foi parcialmente implementado em linguagem de programa��o Java, e testes foram realizados em um aparelho celular Nokia 6275.

O desempenho observado inicialmente foi insatisfat�rio, n�o atendendo aos requisitos de usabilidade estabelecidos na especifica��o. Foram feitas tentativas de melhoria do desempenho, como varia��o do tamanho das chaves, uso de diferentes fun��es de emparelhamento (Ate, Eta) \cite{freeman-scott-teske}, e implementa��es com diferentes bibliotecas que fornecessem a classe \emph{BigInteger}. Algumas adapta��es no esquema em si foram feitas, como invers�o da ordem das curvas utilizadas, por�m sem efeitos consider�veis. 

%TODO: falar das BNCurves em algum ponto...

Os melhores resultados obtidos s�o apresentados na tabela~\ref{tab:BLMQ}.

\begin{table}[h]\centering
\caption{Testes com BLMQ}\label{tab:BLMQ}
\begin{tabular}{cccccc}\hline
Opera��o                   &  Tempo (s)\\\hline
Inicializa��o das classes  &  128.9\\\hline
Emparelhamento Eta         &  4.2\\\hline
Emparelhamento Ate          &  3.9\\\hline
\end{tabular}
\end{table}

Essa implementa��o inicial demandava muito tempo computacional para incializar as classes e realizar as opera��es de emparelhamento. Emparelhamentos s�o extensamente utilizados pelo BLMQ, como nos algoritmos de \emph{signcrypt} e \emph{unsigncrypt}, o que impunha grande \emph{overhead} �s opera��es do sistema. 

Como estes tempos n�o atendiam �s m�tricas e aos requisitos de usabilidade do projeto, fez-se necess�rio buscar outras solu��es. Estas dificuldades serviram como motiva��o para a cria��o de um esquema inovador. Como resultado de pesquisas realizadas, foi idealizado o protocolo, brevemente descrito a seguir.

\section{BDCPS}
%Falar aqui que o Barreto inventou o novo algoritmo, que publicou o SBSEG

O esquema proposto por \cite{bdcps} integra esquemas preexistentes como as assinaturas BLMQ e Schnorr \cite{schnorr} e o esquema isento de certificados de Zheng \cite{zheng}. Neste esquema, a gera��o das chaves dos usu�rios dispensa a necessidade de uma autoridade certificadora e a utiliza��o de certificados convencionais para validar sua chave p�blica. 

\subsection{Vantagens do esquema}
%TODO: Falar mais vantagens al�m desta...
Dentre as opera��es realizadas nos diversos algoritmos, a que apresenta maior custo computacional � a opera��o de emparelhamento. Observa-se que os algoritmos de \emph{Signcrypt} e \emph{Unsigncrypt} n�o executam nenhum emparelhamento.  Estes s�o os algoritmos que ser�o usados mais vezes, j� que s�o usados toda vez que deseja-se enviar ou ler uma mensagem cifrassinada. Os emparelhamentos s�o executados apenas nos algoritmos de valida��o e verifica��o das chaves p�blicas. No entanto, seu custo � amortizado pois esses algoritmos s�o executados apenas uma vez para cada canal seguro estabelecido para um par de usu�rios, isto �, apenas na primeira intera��o. 

Estabelece-se, aqui, um esquema de assinaturas auto-certificado, isto �, n�o � necess�ria a intera��o com uma autoridade de confian�a para que um par de usu�rios estabele�a um canal seguro. A intera��o com a autoridade de confian�a � necess�ria apenas quando um usu�rio gera o seu par de chaves.

\subsection{Testes de viabilidade}
%Tabelinha de testes preliminares, mostrar que ficou bonz�o!
O novo esquema tamb�m foi implementado na plataforma JME (\emph{Java Platform Micro Edition}), e testes para validar a viabilidade foram feitos em diversos modelos de aparelhos celulares, al�m dos emuladores dos ambientes de desenvolvimento \emph{Eclipse} e \emph{NetBeans}.

Os resultados foram satisfat�rios, j� que os tempos de cifrassinatura e vericifra��o estavam de acordo com as m�tricas estabelecidas e bem mais eficientes em rela��o ao esquema inicialmente estudado. 

O tempo necess�rio para validar uma chave p�blica � um pouco maior do que para as demais opera��es. Por�m, conforme observado anteriormente, esta � uma opera��o que ser� executada apenas uma vez para cada nova identidade que se deseje validar. A chave validada fica armazenada na mem�ria do aplicativo, n�o sendo necess�rio valid�-la novamente em uma comunica��o futura com o mesmo par.

Os resultados dos testes preliminares s�o apresentados nas tabelas \ref{tab:bdcps127} e \ref{tab:bdcps160}. Foram feitos testes de viabilidade com chaves de 127 e 160 bits, para dois modelos distintos de celulares: Nokia 6275 e Sony Ericsson W200i.

\begin{table}[h]\centering
\caption{Testes com o novo esquema (chaves de 127 bits) e compara��o com o RSA}\label{tab:bdcps127}
\begin{tabular}{cccccc}\hline
Opera��o                   & Nokia 6275 (s)   &  Sony Ericsson W200i (s) \\\hline
Emparelhamento Eta         & 7,30                   &  2,37                          \\\hline
Emparelhamento Ate         & 7,43                   &  2,38                          \\\hline
Private-Key-Extract        & 2,63                   &  0,93                          \\\hline
Check-Private-Key          & 9,31                   &  2,92                          \\\hline
Set-Public-Value           & 0,66                   &  0,22                          \\\hline
Set-Public-Key             & 3,40                   &  1,15                          \\\hline
Public-Key-Validate        & 10,50                  &  3,35                          \\\hline
Signcrypt                  & 0,57                   &  0,21                          \\\hline
Unsigncrypt                & 0,80                   &  0,29                          \\\hline
Private RSA-508            & 1,05                   &  0,39                          \\\hline
Public RSA-508             & 0,03                   &  0,02                          \\\hline
\end{tabular}
\end{table}

\begin{table}[h]\centering
\caption{Testes com o novo esquema (chaves de 160 bits) e compara��o com o RSA}\label{tab:bdcps160}
\begin{tabular}{cccccc}\hline
Opera��o                   & Nokia 6275 (s)   &  Sony Ericsson W200i (s) \\\hline
Emparelhamento Eta         & 10,53                  &  3,59                          \\\hline
Emparelhamento Ate         & 10,54                  &  3,64                          \\\hline
Private-Key-Extract        & 3,72                   &  1,32                          \\\hline
Check-Private-Key          & 12,70                  &  4,46                          \\\hline
Set-Public-Value           & 0,96                   &  0,33                          \\\hline
Set-Public-Key             & 4,96                   &  1,63                          \\\hline
Public-Key-Validate        & 14,94                  &  5,12                          \\\hline
Signcrypt                  & 0,77                   &  0,31                          \\\hline
Unsigncrypt                & 1,22                   &  0,45                          \\\hline
Private RSA-640            & 1,85                   &  0,74                          \\\hline
Public RSA-640             & 0,16                   &  0,03                          \\\hline
\end{tabular}
\end{table}

\section{An�lise dos resultados preliminares} 
%Falar que escolhemos o BDCPS e trabalharemos com ele daqui pra frente

Pode-se verificar a partir das tabelas \ref{tab:bdcps127} e \ref{tab:bdcps160} que os tempos de assinatura e verifica��o no algoritmo proposto s�o menores do que os do BLMQ e, como observado em \cite{bdcps}, menores do que os de outros protocolos, como o RSA, para um mesmo n�vel de seguran�a.

Desse modo, por ter sido especificamente projetado para as necessidades do cen�rio e ter apresentado �tima efici�ncia, o BDCPS foi escolhido como protocolo de seguran�a para nosso sistema.

%Tinha um texto aqui, que movi pra outra se��o. D� localizar em: Dado que o tempo de uso do RSA de 1024 bits est� no fim .....

\chapter{Especifica��o e projeto}
\section{Arquitetura}

O sistema ser� dividido em dois m�dulos: o m�dulo do cliente, que possibilitar� ao usu�rio a troca de mensagens com outros usu�rios, e o m�dulo da autoridade certificadora, ou \emph{KGB}, que ser� respons�vel pela gera��o de parte da chave privada dos usu�rios, conforme a Figura \ref{fig:deploy_diagram}. 

\begin{figure}[h]
	\centering
		\includegraphics[width=0.70\textwidth]{figuras/DeploymentDiagram.png}
	\caption{Diagrama de implanta��o do sistema}
	\label{fig:deploy_diagram}
\end{figure}

\section{Classes}
%Diag de classes aqui, e descri��o das classes
\subsection{Descri��o}
As classes do sistema s�o divididas em 4 pacotes: 
\begin{itemize}
\item \textbf{Protocol:} pacote que cont�m as classes que implementam o protocolo de seguran�a BDCPS.
\item \textbf{Data:} pacote que cont�m as classes que gerenciam a persist�ncia dos dados da aplica��o.
\item \textbf{Application:} pacote que cont�m a interface gr�fica e as classes que gerenciam os servi�os do usu�rio e da autoridade de seguran�a (KeyGenerationBureau).
\item \textbf{Messaging:} pacote que cont�m as classes que gerenciam a interface com o servi�o de mensagens SMS e a serializa��o dos dados trafegados nas mensagens bin�rias.
\end{itemize}
A figura \ref{fig:class_diagram} apresenta um diagrama de classes simplificado do sistema. O ap�ndice \ref{app:classe_detalhados} apresenta diagramas de classe detalhados de cada pacote.
\begin{figure}[h]
	\centering		\includegraphics[width=1.00\textwidth]{figuras/class_diagram.PNG}
	\caption{Diagrama de classes do sistema}
	\label{fig:class_diagram}
\end{figure}

\section{Especifica��o do protocolo de troca de mensagens}

%Falar das nossas primitivas, como � feita serializa��o dos bytes em cada mensagem, etc
%Deixa que eu fa�o (Eduardo)

O interc�mbio de mensagens entre clientes, ou entre um cliente e a autoridade de confian�a, se d� atrav�s do envio de mensagens  bin�rias de SMS. Em nosso sistema existem 4 tipos de mensagens (4 primitivas). Nesta se��o apresentamos como � feita a divis�o de bytes em cada tipo de mensagem \footnote{Os bytes de uma mensagem ser�o numerados iniciando de 1.}. A figura \ref{fig:SequenceDiagramKGB} ilustra o fluxo de estabelecimento da chave privada de um usu�rio com a autoridade certificadora. O figura \ref{fig:SequenceDiagramClient} ilustra o fluxo de autentica��o e troca de mensagens entre dois usu�rios. As se��es seguintes especificam o formato de cada primitiva do sistema.

\begin{figure}[h]
	\centering		\includegraphics[width=1.00\textwidth]{figuras/SequenceDiagramKGB.png}
	\caption{Estabelecimento da chave privada com a autoridade certificadora}	
	\label{fig:SequenceDiagramKGB}
\end{figure}

\begin{figure}[h]
	\centering	\includegraphics[width=1.00\textwidth]{figuras/SequenceDiagramClient.png}
	\caption{Fluxo de comunica��o entre dois usu�rios}	
	\label{fig:SequenceDiagramClient}
\end{figure}

\subsection{SignupMessage}
Representa a mensagem que um cliente $A$ envia para \emph{KGB} contendo sua chave p�blica $y_A$.

\begin{itemize}
	\item Byte 1: Byte fixo que identifica uma mensagem do nosso protocolo. Valor $0x42$.
	\item Byte 2: Byte fixo, identifica a primitiva \textbf{SignupMessage}. Valor $0x00$.
	\item Byte 3: Leva o valor do n�mero de bits $k$ usado na opera��o, como um inteiro sem sinal.
	\item Byte 4: Byte reservado para algum poss�vel uso em uma vers�o futura. Nesta vers�o tem valor $0x00$.	
	\item Byte 5: Armazena um n�mero que informa o comprimento em bytes do par�metro $y_A$.
\end{itemize}	
A partir do byte 6, ocorre o armazenamento din�mico dos par�metros. � reservado para cada par�metro o espa�o especificado nos bytes anteriores.
\begin{itemize}
	\item Par�metro 1: O $y_A$.
\end{itemize}

\begin{figure}[h]
	\centering
		\includegraphics{figuras/requestmyqamessage.PNG}
	\caption{SignupMessage}
	\label{fig:SignupMessage}
\end{figure}

\subsection{SignupResponse}
Representa a mensagem que a KGB envia a um usu�rio $A$ sua chave privada parcial $Q_A$ gerada a partir de e encriptada usando a chave p�blica $y_A$ do usu�rio. Somente um usu�rio em posse do $x_A$ associado ao $y_A$ poder� abrir o $Q_A$ contido nesta mensagem.

\begin{itemize}
	\item Byte 1: Byte fixo que identifica uma mensagem do nosso protocolo. Valor $0x42$.
	\item Byte 2: Byte fixo, identifica a primitiva \textbf{SignupResponse}. Valor $0x01$.
	\item Byte 3: Leva o valor do n�mero de bits $k$ usado na opera��o, como um inteiro sem sinal.
	\item Byte 4: Byte reservado para algum poss�vel uso em uma vers�o futura. Nesta vers�o tem valor $0x00$.	
	\item Byte 5: Armazena um n�mero que informa o comprimento em bytes do par�metro $c$.
	\item Byte 6: Armazena um n�mero que informa o comprimento em bytes do par�metro $h$.
	\item Byte 7: Armazena um n�mero que informa o comprimento em bytes do par�metro $z$.
\end{itemize}	
A partir do byte 8, ocorre o armazenamento din�mico dos par�metros. � reservado para cada par�metro o espa�o especificado nos bytes anteriores.
\begin{itemize}
	\item Par�metro 1: Par�metro $c$, parte do criptograma.
	\item Par�metro 2: Par�metro $h$, parte do criptograma.
	\item Par�metro 3: Par�metro $z$, parte do criptograma.	
\end{itemize}

\begin{figure}[h]
	\centering
		\includegraphics{figuras/hereisyourqamessage.PNG}
	\caption{SignupResponse}	
	\label{fig:SignupResponse}
\end{figure}

\subsection{ValidationMessage}
Representa a mensagem pela qual um usu�rio envia sua chave p�blica $y_A$ para um outro usu�rio. Os par�metros $h_A$ e $t_A$ tamb�m s�o enviados, pois ser�o usados pelo outro usu�rio para validar a chave p�blica $y_A$ (funcionam quase como um certificado para o $y_A$).

\begin{itemize}
	\item Byte 1: Byte fixo que identifica uma mensagem do nosso protocolo. Valor $0x42$.
	\item Byte 2: Byte fixo, identifica a primitiva \textbf{ValidationMessage}. Valor $0x02$.
	\item Byte 3: Leva o valor do n�mero de bits $k$ usado na opera��o, como um inteiro sem sinal.
	\item Byte 4: Byte reservado para algum poss�vel uso em uma vers�o futura. Nesta vers�o tem valor $0x00$.	
	\item Byte 5: Armazena um n�mero que informa o comprimento em bytes do par�metro $y_A$.
	\item Byte 6: Armazena um n�mero que informa o comprimento em bytes do par�metro $h_A$.
	\item Byte 7: Armazena um n�mero que informa o comprimento em bytes do par�metro $T_A$.
\end{itemize}	
A partir do byte 8, ocorre o armazenamento din�mico dos par�metros. � reservado para cada par�metro o espa�o especificado nos bytes anteriores.
\begin{itemize}
	\item Par�metro 1: Par�metro $y_A$, a chave p�blica.
	\item Par�metro 2: Par�metro $h_A$.
	\item Par�metro 3: Par�metro $T_A$.
\end{itemize}

\begin{figure}[h]
	\centering
		\includegraphics{figuras/authenticationmessage.PNG}
	\caption{ValidationMessage}
	\label{fig:ValidationMessage}
\end{figure}


\subsection{SigncryptedMessage}
Representa uma mensagem cifrassinada a ser trocada entre usu�rios.

\begin{itemize}
	\item Byte 1: Byte fixo que identifica uma mensagem do nosso protocolo. Valor $0x42$.
	\item Byte 2: Byte fixo, identifica a primitiva \textbf{SigncryptedMessage}. Valor $0x03$.
	\item Byte 3: Leva o valor do n�mero de bits $k$ usado na opera��o, como um inteiro sem sinal.
	\item Byte 4: Byte reservado para algum poss�vel uso em uma vers�o futura. Nesta vers�o tem valor $0x00$.	
	\item Byte 5: Armazena um n�mero que informa o comprimento em bytes do par�metro $c$.
	\item Byte 6: Armazena um n�mero que informa o comprimento em bytes do par�metro $h$.
	\item Byte 7: Armazena um n�mero que informa o comprimento em bytes do par�metro $z$.
\end{itemize}	
A partir do byte 8, ocorre o armazenamento din�mico dos par�metros. � reservado para cada par�metro o espa�o especificado nos bytes anteriores.
\begin{itemize}
	\item Par�metro 1: Par�metro $c$, parte do criptograma.
	\item Par�metro 2: Par�metro $h$, parte do criptograma.
	\item Par�metro 3: Par�metro $z$, parte do criptograma.	
\end{itemize}

\begin{figure}[h]
	\centering
		\includegraphics{figuras/signcryptedmessage.PNG}
	\caption{SigncryptedMessage}
	\label{fig:signcryptedmessage}
\end{figure}

\chapter{Implementa��o}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% IMPLEMENTA��O
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
A implementa��o foi feita na linguagem \emph{Java}, plataforma \emph{J2ME MIDP-1.0 CLDC-1.1}.
%TODO: escrever mais?
%\section{Metodologia}
%sacrifiquei essa se��o
\section{Ambiente de desenvolvimento}
Para o desenvolvimento do c�digo, foi usado o \emph{IDE Netbeans 6.0.1}, integrado com o \emph{Sun Java (TM) Wireless Toolkit 2.5.2 for CLDC (WTK)}. Usamos o emulador do \emph{WTK} para auxiliar o processo de desenvolvimento. Tamb�m foi usado o \emph{Subversion}\footnote{sistema de gerenciamento de configura��o dispon�vel em http://subversion.tigris.org} para controle de vers�o e coordena��o do trabalho em equipe, hospedado nos servidors do \emph{Google Code}\footnote{http://code.google.com/}.
%Netbeans, Wireless ToolKit, 
\section{Bibliotecas utilizadas}
%Floggy, BouncyCastle, SMSPairings do Barreto
\subsection{SMSPairings}
A biblioteca \emph{SMSPairings} foi fornecida por nosso orientador. Cont�m classes que implementam curvas el�pticas e emparelhamentos bilineares, de uma forma otimizada para a ordem de grandeza de nossas chaves.
%TODO: falar mais
\subsection{BouncyCastle}
%TODO: citar o site do bouncycastle?
O \emph{BouncyCastle} � uma biblioteca que cont�m implementa��es de v�rios algoritmos de criptografia e \emph{hashs}. Existe uma vers�o da biblioteca implementada para o ambiente \emph{J2ME}, a qual usamos. Fez-se necess�rio o uso desta biblioteca devido � aus�ncia dos pacotes \emph{java.security} e \emph{javax.crypto} no ambiente dos celulares usados. Estas bibliotecas s�o opcionais do \emph{framework J2ME}, e n�o estava presente nos celulares que usamos para desenvolver e testar. Assim, usamos a biblioteca \emph{BouncyCastle} como substituta para estes pacotes ausentes.
\subsection{Floggy}
%TODO: citar o site do floggy?
O \emph{Floggy} � um \emph{framework} de persist�ncia de dados em ambiente \emph{J2ME}, desenvolvido no Brasil. Foi essencial para nosso projeto para persistir objetos como mensagens cifrassinadas recebidas, contatos validados e dados do protocolo, como a chave privada parcial $Q_A$;

\section{Escolha de par�metros}

\subsection{Escolha do tamanho de chave}\label{sec:escolhatamanhochave}

Nossa aplica��o � capaz de trabalhar com um tamanho de chave de $k$ bits, se $k \in \{80, 96, 104, 112, 117, 127, 142, 160, 176, 187, 256, 272, 313\}$. N�o podemos simplesmente usar qualquer valor, pois � necess�rio o uso de uma curva adequada (MNT4) para cada valor. Nem sempre � poss�vel encontrar uma curva adequada para um dado tamanho em bits, assim ficamos limitados a usar valores que t�m curvas conhecidas associadas a ele. Nota-se um grande intervalo entre os valores 187 e 256, pois n�o foi poss�vel encontrar curvas adequadas no inteiror deste intervalo.

Na escolha do valor ideal, � preciso considerar o tamanho que os par�metros ir�o consumir no espa�o �til da mensagem, al�m do n�vel de seguran�a.

Foi escolhido o n�mero 176 como tamanho de chave padr�o\footnote{O valor pode ser facilmente alterado para qualquer um dos valores suportados sem a necessidade de grande altera��o no c�digo do sistema}, pois este fornece um n�vel de seguran�a equivalente ao do RSA com 704 bits, o que j� representa um n�vel de seguran�a adequado para nossa aplica��o. Por outro lado, n�o � um valor t�o grande que chega a ocupar muitos bytes da mensagem, cada par�metro enviado ter� 176 bits (22 bytes), ocupando apenas $15,7\%$ do tamanho de um segmento SMS (que comporta no m�ximo 140 bytes).%TODO: colocar o valor, e citar. Geovs tem o link, acho...
\subsection{Escolha da porta SMS}
Quando se envia um SMS, associa-se a ele uma porta. A porta � um valor inteiro entre 0 e 65535 que serve para que o receptor encaminhe a mensagem recebida a uma aplica��o espec�fica. No caso de um SMS de texto normal, o valor da porta � 0. Quando um sistema operacional de um telefone m�vel recebe uma mensagem com o valor de porta 0 ele aciona as rotinas do pr�prio sistema operacional para trat�-la, como armazen�-la na caixa de entrada e tocar um som de alerta para o usu�rio. No caso de a porta ser diferente de 0, o sistema operacional procura numa �rea chamada \emph{PushRegistry} por algum aplicativo instalado que deseja receber mensagens nesta porta (� como se o aplicativo estivesse escutando a porta) e assim executa aplicativo registrado, que ir� tratar a mensagem recebida\footnote{Em alguns celulares, o sistema operacional pode pedir uma confirma��o do usu�rio antes de executar a aplica��o automaticamente.}.

Sendo assim, escolhemos arbitrariamente o valor 50001 para usar como a porta de nossa aplica��o. A aplica��o envia e se registra para escutar mensagens nesta porta.

\section{Telas do sistema}
As telas do sistema s�o apresentadas no ap�ndice \ref{app:telas}.


\chapter{Resultados}
Ap�s implementado, o sistema foi testado usando diferentes celulares e diferentes operadoras. 
\section{Desempenho}

Foram executados testes de desempenho com a vers�o final do sistema. Na tabela \ref{tab:bdcps176final} podemos observar os tempos das opera��es usando chaves de 176 bits.

No ap�ndice \ref{app:desempenho} apresentamos um gr�fico demonstrando como o tempo da opera��o de cifrassinatura varia conforme o tamanho da mensagem. Tamb�m acrescentamos gr�ficos demonstrando como estes tempos variam de acordo com o tamanho de chave usado. Neste teste, foram utilizados os valores de chave suportados pela aplica��o, explicitados na se��o \ref{sec:escolhatamanhochave}

\begin{table}[h]\centering
\caption{Testes com a implementa��o final (chaves de 176 bits)} \label{tab:bdcps176final}
\begin{tabular}{cccccc}\hline
Opera��o                   & Nokia E51(ms)   &  Nokia 6275(ms) & Emulador(ms)\\\hline
Set-Public-Value	&	66,9	& 750,6  & 204,5	 \\\hline
Private-Key-Extract &	379,0 &	4381,7 &	1033,9 \\\hline
Check-Private-Key	& 1164,9	& 12171,1  & 3209,9	 \\\hline
Set-Public-Key	& 379,5 &	4332,4 &	1013,3 \\\hline
Public-Key-Validate	&	1192,6 &	13112,0 & 3455,8 \\\hline
Signcryption	&302,4 &	1633,5 & 	428,8 \\\hline
Unsigncryption	&	266,7 &	1957,0 & 492,2 \\\hline
\end{tabular}
\end{table}

O ap�ndice \ref{app:desempenho} apresenta gr�ficos e tabelas com dados de desempenho mais detalhados.

\section{Testes entre operadoras}
Realizamos testes de envio de mensagens de nossa aplica��o entre celulares habilitados para operadoras distintas. Foram testadas as principais operadoras do estado de S�o Paulo: \emph{Vivo}, \emph{Tim} e \emph{Claro}. Observou-se que em alguns casos o SMS enviado n�o era recebido na porta \emph{SMS} especificada no envio: mesmo sendo encaminhada � porta 50001, a mensagem era recebida na porta 0 (a porta padr�o do SMS), n�o alcan�ando a aplica��o e sim a caixa de entrada padr�o do celular.

Na tabela \ref{tab:operadoras} apresentamos o resultado de nossos testes, informando quais s�o as combina��es em que o nosso sistema funcionou corretamente.

\begin{table}[h]\centering
\caption{Compatibilidade entre operadoras}\label{tab:operadoras}
\begin{tabular}{cccccc}\hline
   & Vivo  &  Tim & Claro\\\hline
Vivo & OK & NOK & NOK\\\hline
Tim & NOK & OK & OK\\\hline
Claro & NOK & OK & OK\\\hline
\end{tabular}
\end{table}

Este problema ocorre devido �s implementa��es internas das integra��es entre as operadoras, sendo imposs�vel resolv�-lo em n�vel de aplica��o. Seria necess�rio uma negocia��o com as operadoras, solicitando a completa integra��o de uma porta espec�fica para o uso de nosso sistema . Por estar fora do escopo de nosso projeto, este problema n�o foi tratado.

\chapter{Conclus�o}
Ao longo do trabalho, foi poss�vel observar que a criptografia em curvas el�pticas (\emph{ECC}) j� � uma alternativa vi�vel em ambientes com restri��es, principalmente de banda, como os servi�os de telefonia m�vel, apesar de sua consider�vel exig�ncia de poder computacional. No entanto, o uso de esquemas h�bridos, como o aqui proposto, alia as melhores qualidades dos dois paradigmas, possibilitando a implanta��o imediata de sistemas de seguran�a completos no contexto de dispositivos e aplica��es m�veis.

\section{An�lise dos resultados}
O sistema de modo geral funcionou de acordo com o esperado, satisfazendo os requisitos e m�tricas propostos. Os resultados apresentados mostram tempos excelentes, atingindo assim as m�tricas de usabilidade desejadas, e comprovam a adequa��o do protocolo de seguran�a.

\section{Perspectivas futuras}
Apesar de j� termos apresentado um sistema de seguran�a funcional, pronto para o uso, existem ainda pontos em que ele pode ser aperfei�oado. Especificamente, o protocolo de seguran�a utilizado n�o fornece os servi�os de irretratabilidade e revoga��o de chaves. O servi�o de irretratabilidade poderia ser implantado com o uso de outros protocolos de cifrassinatura, no entanto ao custo de degrada��o do desempenho devido ao uso mais extenso de emparelhamentos \cite[section~3]{bdcps}.

Por outro lado, s�o amplas as possibilidades de aplica��es do sistema em ambientes reais, entre as quais podemos citar transa��es banc�rias, pagamentos por celular e comunica��o corporativa. Acreditamos que conceitualmente o sistema j� esteja maduro o suficiente para este tipo de aplica��o, ficando pendentes apenas estudos mais detalhados sobre as necessidades espec�ficas de cada cen�rio de implanta��o.

\section{Considera��es finais}
No decorrer do desenvolvimento deste trabalho, superamos as dificuldades tecnol�gicas impostas de maneira inovadora, gerando pesquisa e produzindo publica��es \cite{ssms, bdcps} reconhecidas no meio acad�mico nacional. Esperamos, tamb�m, ter aberto caminho para novas pesquisas e desenvolvimentos na �rea de criptografia para dispositivos m�veis, ainda pouco explorada.

\bibliography{Monografia}

\appendix

\chapter{Diagramas de classe detalhados}\label{app:classe_detalhados}

\begin{sidewaysfigure}[h]
	\centering
		\includegraphics[width=1.00\textwidth]{figuras/ClassDiagramApplication.png}
	\caption{Diagrama de classes do pacote Application}
	\label{fig:ClassDiagramApplication}
\end{sidewaysfigure}

\begin{sidewaysfigure}[h]
	\centering
		\includegraphics[width=1.00\textwidth]{figuras/ClassDiagramData.png}
	\caption{Diagrama de classes do pacote Data}
	\label{fig:ClassDiagramData}
\end{sidewaysfigure}

\begin{sidewaysfigure}[h]
	\centering
		\includegraphics[width=1.00\textwidth]{figuras/ClassDiagramMessaging.png}
	\caption{Diagrama de classes do pacote Messaging}
	\label{fig:ClassDiagramMessaging}
\end{sidewaysfigure}

\begin{sidewaysfigure}[h]
	\centering
		\includegraphics[width=1.00\textwidth]{figuras/ClassDiagramProtocol.png}
	\caption{Diagrama de classes do pacote Protocol}
	\label{fig:ClassDiagramProtocol}
\end{sidewaysfigure}

\chapter{Telas do sistema}\label{app:telas}
\begin{figure}[h]
	\centering
		\includegraphics{figuras/telainicial.PNG}
	\caption{Tela inicial do sistema}
\end{figure}

\begin{figure}[h]
	\centering
		\includegraphics{figuras/telaprimeirouso.PNG}
	\caption{Tela de primeiro uso do sistema}
\end{figure}

\begin{figure}[h]
	\centering
		\includegraphics{figuras/telavalidarcontato.PNG}
	\caption{Tela de valida��o de contatos}
\end{figure}

\begin{figure}[h]
	\centering
		\includegraphics{figuras/telalistacontatos.PNG}
	\caption{Tela de lista de contatos}
\end{figure}

\begin{figure}[h]
	\centering
		\includegraphics{figuras/telaenviarmensagem.PNG}
	\caption{Tela de envio de mensagem}
\end{figure}

\begin{figure}[h]
	\centering
		\includegraphics{figuras/telalistamensagens.PNG}
	\caption{Tela de lista de mensagens}
\end{figure}

\begin{figure}[h]
	\centering
		\includegraphics{figuras/telalermensagem.PNG}
	\caption{Tela da caixa de entrada}
\end{figure}

\chapter{Desempenho da implementa��o final}\label{app:desempenho}

\begin{sidewaysfigure}[h]
	\centering
		\includegraphics{figuras/teste_variando_tamanho_mensagem.PNG}
	\caption{Gr�fico: tempo de Signcrypt x tamanho da mensagem}
	\label{fig:teste_variando_tamanho_mensagem}
\end{sidewaysfigure}

\begin{table}[h]\centering
\caption{Medida de tempo de Signcrypt x tamanho da mensagem} \label{tab:signxmsgfinal}
\begin{tabular}{cccccc}\hline
Tam. Msg (bytes)	&Emulador(ms)	&Nokia E51(ms)	&Nokia 6275(ms)\\\hline
8	& 387,3	& 183,0	& 1440,8\\\hline
28	& 393,6	& 144,8	& 1383,9\\\hline
48	& 396,4	& 167,8	& 1369,6\\\hline
68	& 388,1	& 148,8	& 1372,9\\\hline
88	& 394,9	& 192,6	& 1394,0\\\hline
108	& 397,2	& 157,9	& 1393,1\\\hline
128	& 393,0	& 173,3	& 1381,0\\\hline
148	& 397,3	& 149,4	& 1386,4\\\hline
168	& 391,4	& 235,3	& 1391,3\\\hline
188	& 394,7	& 147,4	& 1378,8\\\hline
208	& 400,7	& 191,2	& 1395,9\\\hline
228	& 393,9	& 151,6	& 1384,6\\\hline
248	& 398,2	& 171,6	& 1387,1\\\hline
268	& 396,6	& 147,7	& 1406,1\\\hline
288	& 395,1	& 197,4	& 1405,6\\\hline
308	& 398,4	& 159,9	& 1401,6\\\hline
328	& 394,6	& 190,0	& 1410,8\\\hline
348	& 395,5	& 189,7	& 1409,9\\\hline
\end{tabular}
\end{table}


\begin{sidewaysfigure}[h]
	\centering
		\includegraphics{figuras/teste_nokiae51.PNG}
	\caption{Gr�fico: tempo das opera��es x tamanho da chave (Nokia E51)}
	\label{fig:teste_nokiae51}
\end{sidewaysfigure}

\begin{sidewaysfigure}[h]
	\centering
		\includegraphics{figuras/teste_nokia6275.PNG}
	\caption{Gr�fico: tempo das opera��es x tamanho da chave (Nokia 6275)}
	\label{fig:teste_nokia6275}
\end{sidewaysfigure}

\begin{sidewaysfigure}[h]
	\centering
		\includegraphics{figuras/teste_emulador.PNG}
	\caption{Gr�fico: tempo das opera��es x tamanho da chave (Emulador WTK2.5.2)}	\label{fig:teste_emulador}
\end{sidewaysfigure}

\end{document}


