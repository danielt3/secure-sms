\documentclass[a4paper,capchap,espacoduplo,normaltoc]{abntepusp}

%\usepackage[bookmarks,pdftex,a4paper,colorlinks=true,citecolor=black,urlcolor=blue,linkcolor=black,pdfpagemode=None]{hyperref}
%\usepackage[bookmarks,a4paper,colorlinks=true,citecolor=black,urlcolor=blue,linkcolor=black,pdfpagemode=None]{hyperref}
\usepackage[centertags]{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage[brazil]{babel}
\usepackage[alf,abnt-repeated-author-omit=yes]{abntcite}
\usepackage{url}
\usepackage{winfonts}
\usepackage{txfonts}
\usepackage{tabela-simbolos}
\usepackage{graphics}

\fontfamily{arial}\selectfont
\renewcommand{\rmdefault}{arial}

% Math -------------------------------------------------------------------
\newtheorem{theorem}{Teorema}{\bfseries}{\itshape}
\newtheorem{lemma}{Lema}{\bfseries}{\itshape}
\newtheorem{definition}{Definição}{\bfseries}{\itshape}
\newtheorem{corollary}{Corolário}{\bfseries}{\itshape}

\sloppy

\begin{document}

\renewcommand{\bibname}{Refer\^encias} % adaptação para ABNT/EPUSP

%\autorPoli{Eduardo}{Cruz}

%Gambis para definir múltiplos autores
\autor{\uppercase{Eduardo de Souza Cruz
	\\Geovandro Carlos Crepaldi Firmino Pereira
	\\Rodrigo Rodrigues da Silva}}
	
\renewcommand{\PoliAutorFichaCatalografica}{{Cruz, Eduardo de Souza\newline
 Pereira, Geovandro Carlos Crepaldi Firmino\newline
 Silva,Rodrigo Rodrigues}}
 

\newcommand{\F}{\mathbb{F}}
\newcommand{\G}{\mathbb{G}}
\newcommand{\ID}{\mathsf{ID}}
\newcommand{\Z}{\mathbb{Z}}
	
\titulo{Aplicativo de SMS Seguro}

\orientador{Prof. Dr. Paulo Sérgio Licciardi Messeder Barreto}

\monografiaFormatura
%\monografiaMBA
%\qualificacaoMSc{<Área do Mestrado>}
%\qualificacaoMSc{Enge\-nharia Elétrica}
%\dissertacao{<Área do Mestrado>}
%\qualificacaoDr{<Área do Mestrado>}
%\teseDr{<Área do Doutorado>}
%\teseLD
%\memorialLD

%\comentario{\vspace{1.5cm}
%	Trabalho de Conclusão de Curso
%	apresentado à Escola Politécnica da
%	Universidade de São Paulo para
%	obtenção do Título de Engenheiro da
%	Computação.}%
  
\areaConcentracao{Engenharia da Computação}

\departamento{Departamento de Engenharia de Computação e Sistemas Digitais (PCS)}

\local{São Paulo}

\data{2008}

\dedicatoria{}

%TODO: gerar a capa real

\capa{} %TODO: Isto está gerando na verdade a falsa folha de rosto

\folhaderosto{} %TODO: eliminar a quebra de página

%
% Ficha Catalográfica
% (deve ficar no verso da página de rosto)
%
\renewcommand{\PoliFichaCatalograficaData}{% TODO: consertar
  1. Criptografia. 2. Assunto \#2. 3. Assunto \#3.
  I. Universidade de São Paulo. Escola Politécnica.
  \PoliDepartamentoData. II. t.}

%\renewcommand{\PoliAutorFichaCatalografica}{{Cruz, Eduardo de Souza
%	\\Pereira, Geovandro Carlos Crepaldi Firmino
%	\\Silva, Rodrigo Rodrigues}}%

%TODO: porque ocorre 3 erros? Mas compila...
%\fichacatalografica % formata a ficha

\paginadedicatoria{}

\begin{agradecimentos}
%TODO
Agradeço a... etc etc etc 
\end{agradecimentos}

\begin{resumo}
Este trabalho consiste na especificação e implementação de um sistema que garanta serviços de segurança na troca de mensagens SMS entre aperelhos de telefonia celular. Ao longo da monografia, apresentaremos aspectos da nossa solução, um esquema criptográfico inovador que viabilizou a implementação, métricas, resultados de testes de desempenho, além de considerações sobre o andamento do trabalho.
%TODO: atualizar isso depois de ter feito tudo
\end{resumo}

\begin{abstract}
%TODO
This work consists in the specification and implementation of a system which is able to guarantee security services while exchanging SMS between

\end{abstract}

\tableofcontents

\listoffigures

\listoftables

%TODO: \sigla não funciona!!!
%To fazendo a lista de siglas na mão... consertar depois talvez
\listadesiglas{
\begin{center}
\textbf{SMS} - Short Message Service\\
\textbf{ECC} - Elliptic Curve Cryptography
%TODO: acrescentar as siglas aqui
%Existe uma norma, acho que é pra por na ordem de aparição no texto... ou em ordem alfabética.. não sei, TODO: confirmar nas diretrizes
\end{center}
}


\chapter{Introdução}
Atualmente não existem soluções universalmente adotadas para garantir segurança em mensagens SMS. Pelo método tradicional, as mensagens trafegam pela rede celular de forma insegura, passando obrigatoriamente por pelo menos um intermediário não 100\% confiável: a operadora do serviço de telefonia. As mensagens podem ficar armazenadas em texto plano no banco de dados da operadora \cite{loon}, de forma que pessoas mal intencionadas infiltradas no sistema podem ser capazes de visualizar, alterar e até enviar mensagens em nome de outra pessoa. Há também outros métodos para interceptar mensagens SMS. \cite{smsanalysis}. %TODO: quais métodos??? Tá mto pobre isso!

O sistema desenvolvido foi designado por "Aplicativo Seguro de SMS", ou, em uma forma abreviada e internacionalizada mais adequada ao mercado, "Secure-SMS", ou ainda "SSMS".  %TODO: manteremos o nome?
O objetivo do sistema é prover uma camada de segurança a nível de aplicação para mensagens SMS em redes de telefonia móvel. O software é capaz de assinar, cifrar, decifrar e verificar mensagens enviadas por SMS, de forma a garantir a identidade do remetente, e garantir que ela somente poderá ser lida pelo destinatário real, oferencendo assim os serviços de segurança: autenticidade, confidencialidade e integridade. %TODO: revisar isto depois

Apesar de implementado especificamente para ser executado em um telefone celular, garantindo a comunicação pessoal sigilosa, o mesmo esquema pode ser facilmente portado para outras plataformas que têm acesso à comunicação por SMS, como PDAs ou servidores. Desta forma, o esquema pode ser aplicado em áreas que requerem alto nível de segurança da informação que trafega nas redes de telefonia móvel, por exemplo aplicações militares, bancárias, e de comércio eletrônico.

%Como possíveis aplicações de nossa solução, podemos citar a realização de transações bancárias usando mensagens SMS, sistemas de %comunicação que requeiram confidencialidade e integridade (órgãos militares e governamentais, executivos de grandes empresas) ou apenas %usuários comuns em busca de maiores níveis de privacidade.

\section{Cenário} %Falar dos limitantes, processamento e tamanho de mensagem pequenos

Na figura \ref{fig:Canal_Inseguro}, as entidades A (Alice) e B (Bob) estão se comunicando sobre um canal inseguro. Assumimos que todas as comunicações têm a presença de um agressor E (Eve) cujo objetivo é explorar falhas nos serviços de segurança sendo fornecidos por A e B.


\begin{figure}[h]
	\centering
		\includegraphics{figuras/Canal_Inseguro.jpg}
	\caption{Canal inseguro}
	\label{fig:Canal_Inseguro}
\end{figure}

Por exemplo, A e B poderiam ser 2 pessoas comunicando-se sobre uma rede de telefonia celular, e E está tentando interceptar a comunicação. 

Ou, $\sim A$ poderia ser um web browser de um indivíduo A que está em processo de compra de um produto de uma loja online $\sim B$ representada por seu site B. Neste cenário, o canal de comunicações é a internet. Um agressor E poderia tentar ler o tráfego entre A e B, portanto saber a informação sobre o cartão de crédito de A, ou poderia tentar personificar A ou B na transação. 
Como um terceiro exemplo, considere a situação onde A está enviando uma mensagem via email para B sobre a internet. Um agressor E poderia tentar ler a mensagem, modificar pedaços selecionados, ou personificar A enviando mensagens dela mesma para B. Finalmente, considere o cenário onde A é um smart card que está em processo de autenticar seu possuidor $\sim A$ em um computador mainframe B em uma sala protegida do banco. Aqui, E poderia tentar monitorar as comunicações para obter informações sobre a conta de $\sim A$ , ou poderia tentar personificar $\sim A$ para sacar fundos da conta de $\sim A$. Deveria ser evidente destes exemplos que uma entidade se comunicando não é necessariamente um humano, mas pode ser um computador, smart card, ou um módulo de software agindo no lugar de um indivíduo ou uma organização tal como uma loja ou um banco.

O ambiente em questão não se mostra muito propício para práticas criptográficas. A largura de banda é muito pequena, visto que em cada mensagem SMS podem ser trafegados apenas 140 bytes binários \cite{ortiz}.
Além disto, existem limitações de processamento no dispositivo celular, que podem comprometer a usabilidade de um esquema criptográfico tradicional.

%TODO: Tirar esse "talvez"! Citar aqui exemplos de soluções existentes e comparar com cenário no início do ano
Talvez devido a estas dificuldades, o cenário atual não apresenta uma grande variedade de soluções abrangindo objetivos similares aos de nosso sistema, e não há uma solução universalmente adotada.

\chapter{Objetivos}

%fazer um sistema tão difícil de quebrar quanto um sistema vigente atualmente, como transações bancárias por https
O objetivo do trabalho é quebrar o paradigma atual, desafiar as dificuldades existentes, e produzir um sistema que garante segurança no intercâmbio de mensagens SMS entre dispositivos celulares sem afetar a usabilidade do serviço. Além disto, o nível de segurança obtido deve ser equiparável ao nível de segurança de aplicações de segurança vigentes atualmente, como por exemplo uma transação bancária pela Internet pelo protocolo HTTPS.

%fazer um sistema tão difícil de quebrar quanto um sistema vigente atualmente

\section{Escopo}
%Falar aqui exatamente o que o sistema faz e o que ele não faz! Falar de problemas que existem, mas que ficam fora do nosso escopo.
O software a ser desenvolvido será designado por "Sistema de SMS Seguro".
O objetivo do software é prover uma camada de segurança a nível de aplicação para mensagens SMS em redes de telefonia móvel. O software deverá fornecer alguns serviços básicos de segurança como confidencialidade, integridade e autenticidade das mensagens SMS, permitindo ao usuário assinar, cifrar, decifrar e verificar mensagens enviadas por SMS. As soluções adotadas no projeto envolvem criptografia de chave pública, criptografia baseada em idententidade e também esquemas auto-certificados. Tal adoção deve deve dispensar a existência de um diretório de chaves públicas, uma vez que seria necessário o uso de certificados que ocupam muita banda do abiente restrito utilizado e encarece o processo.

O software será aplicável em áreas que requeiram segurança da informação que trafega nas redes de telefonia móvel. Alguns exemplos são aplicações militares, bancárias, comunicação pessoal sigilosa e comércio eletrônico. Os principais benefícios do sistema são a sua flexibilidade, podendo ser adaptado às necessidades dos clientes, e leveza, já que sua arquitetura é restrita à camada de aplicação: o software opera sobre a camada de aplicação do modelo OSI, sendo transparente à arquitetura interna da rede móvel. Essas duas qualidades tornam possível sua viabilidade em diversos cenários.

O Sistema de SMS Seguro não é responsável pela confiabilidade e disponibilidade de entrega das mensagens independente de sua natureza, essa função é de responsabilidade do fornecedor da aplicação que utiliza o protocolo, no caso de mensagens SMS a responsabilidade de entrega será da operadora telefônica, no caso de serviços de e-mail a responsabilidade de entrega é conferida ao servidor que fornece o serviço, etc.

No caso do serviço SMS, se houver qualquer tipo de clonagem de telefone o Sistema Seguro de SMS não mais se responsabiliza pelo serviço de segurança, uma vez que o número do telefone é o identificador do usuário e não mais poderá garantir a autenticidade do emissor das mensagens produzidas pelo dispositivo clonado. Porém, a vantagem do sistema é que ele é capaz de perceber a clonagem quando uma nova mensagem é enviada a partir do telefone clonado.

Uma outra característica não tratada é a irretratabilidade, ou seja, o sistema não fornece este serviço, porém pode ser feita uma pesquisa de viabilidade futura para tornar possível implemetar o serviço de irretratabilidade.

\section{Métricas}

A seguir, definimos as métricas desejadas. % e suas limitações.

\begin{itemize}

\item Nível de segurança: Desejamos que o nível de segurança de nosso protocolo seja equiparável ao nível de segurança do RSA usando chaves de 1024 bits, que pode ser calculado como  2 a 1024. %TODO: fix essa gambi, e citar

\item Tempo de espera: Consiste nos tempos para cifrassinar e vericifrar uma mensagem. Baseando-se em aplicações já existentes e satisfazendo os requisitos de usabilidade de nosso projeto, estimamos que um intervalo de espera para processamento de uma mensagem de no máximo 5 segundos seja tolerável pelo usuário.

\item Tamanho máximo de mensagens do protocolo: Consiste da soma dos bytes úteis da mensagem com os bytes de controle do algoritmo. Implementações SMS baseadas em \emph{Sun Wireless Messaging API (WMA)} podem dividir uma única mensagem em, no máximo, 3 segmentos, totalizando 399 bytes binários \cite{ortiz}. Porém para evitar problemas devido à segmentação, decidimos que as mensagens do nosso protocolo deverão caber em apenas 1 segmento, o que nos dá um tamanho de 140 bytes binários para cada mensagem do protocolo.

\item Tamanho das chaves privada/pública: Devido às limitações de banda, estabeleceu-se que cada o tamanho chave usada não deverá exceder 200 bits. No entanto, essa restrição não deve comprometer o nível de segurança desejado.

\item Tamanho máximo de uma mensagem de texto a ser cifrassinada e enviada: Uma mensagem cifrassinada deverá caber em uma única mensagem do protocolo, cujo tamanho máixmo foi defindo em 140 bytes. Porém nem todos os bytes poderão ser usados para a mensagem, pois existirá um overhead do protocolo, devido à cabeçalhos e dados da assinatura. Estabelecemos então um tamanho máximo de 70 bytes para uma mensagem de texto. Desta forma, ficam reservados outros 70 bytes para o overhead e a assinatura.

\item Tamanho do certificado: Devido às limitações de banda, estabeleceu-se que o tamanho do certificado de uma chave não deverá exceder 512 bits. Desejamos poder transferir o certificado em um único SMS, sem comprometer o espaço necessário para o overhead do protocolo. \footnote{Mais tarde o leitor verá que optamos por um esquema que não usa certificados, ou seja, esta métrica será atendida com 0 bits de tamanho de certificado}

\end{itemize}

\chapter{Discussão}

%TODO: aqui ta tudo igual ao paper... alterar, enriquecer!

Sabendo que um certificado digital típico ocupa entre 2KB e 4KB, nota-se aqui que uma solução baseada em infra-estrutura convencional de chaves públicas inviabilizaria completamente o sistema: antes de se enviar uma mensagem SMS segura para algum usuário, seria necessário receber o certificado desse usuário particionado em 15 a 30 mensagens SMS, além de enviar em resposta outro certificado em mais 15 a 30 mensagens SMS. Esse esforço precisaria ser efetuado novamente para cada novo destinatário a quem determinado usuário desejasse enviar mensagens, ou em cada caso de renovação ou revogação de certificado. Some-se a isto o espaço ocupado por uma única assinatura convencional, tipicamente de 128 bytes por estar baseada no algoritmo RSA com 1024 bits; este \emph{overhead} seria duplicado com o requisito de cifrar e assinar a mensagem, isto é, tomaria 256 bytes do espaço disponível. 

Por outro lado, a manutenção de um diretório confiável de chaves públicas, típico de sistemas de criptografia convencionais, seria impraticável em uma rede de telefonia celular.  Uma solução tecnológica baseada em alternativas à criptografia convencional é, portanto, imprescindível.

Sendo assim, foi considerado o uso de criptografia em curvas elípticas com assinatura baseada em identidades, de acordo com o conceito proposto inicialmente por Shamir \cite{shamir}. Aprofundando-se na especificação, percebeu-se ainda que a chave pública do usuário poderia ser estabelecida essencialmente a partir de sua identificação única no sistema, ou seja, seu próprio número de celular. Desse modo, a criptografia em curvas elípticas baseada em identidades com emparelhamentos bilineares parecia ser capaz de atender aos requisitos do nosso aplicativo.%. e foi inicialmente adotada na solução do projeto.

\chapter{Preliminares teóricas}% (assunto geral: curvas elípticas, emparelhamento, identidadesz protocolos, conceitos, etc)

\section{Serviços de Segurança}

Alguns dos principais serviços de segurança da informação estão listados abaixo:

\begin{itemize}
\item Confidencialidade: manter secretos os dados de todos a não ser aqueles autorizados a vê-los - mensagens enviadas por A para B não deveriam ser legíveis para .
\item Integridade dos dados: assegurar que os dados não foram alterados por entidades não autorizadas significa - B deveria ser capaz de detectar quando dados enviados por A foram modificados por E.
\item Autenticação da origem dos dados: confirmar a fonte dos dados - B deveria ser capaz de verificar que dados propositalmente enviados por A de fato foram originados por A.
\item Autenticação da entidade: confirmar a identidade da entidade: B deveria se convencer da identidade da outra entidade em comunicação.
\item Irretratabilidade: prevenir uma entidade de negar comprometimentos ou atos anteriores - Quando B recebe uma mensagem propositalmente de A, não apenas B está convencido de que a mensagem se originou em A, mas B pode convencer uma terceira parte disso; portanto A não pode negar ter enviado a mensagem para B.
Algumas aplicações podem ter outros objetivos de segurança tais como anonimato das entidades em comunicação ou controle de acesso (a restrição de acessar recursos).
\end{itemize}


\section{Criptografia de Chave Simétrica}

\subsection{Introdução}

Os sistemas criptográficos podem ser amplamente divididos em dois tipos. Em esquemas de chave simétrica, as entidades em comunicação compartilham uma informação, usada como chave, que é ao mesmo tempo secreta e autêntica. Conseqüentemente, eles podem usar um esquema de encriptação simétrica tal como o Data Encryption Standard (DES), RC4, ou o Advanced Encryption Standard (AES) para integrar confidencialidade. 

Eles também podem usar um algoritmo de código de autenticação de mensagens (MAC) tal como o HMAC para reunir integridade e autenticação da origem dos dados.
Por exemplo, se confidencialidade fosse desejada e a chave secreta compartilhada entre A e B fosse k, então A encriptaria uma mensagem m, em texto claro, usando uma função de encriptação ENC e a chave k e transmitiria a cifra resultante c - ENCk (m) para B. Ao receber c, B usaria a função de decriptação DEC e a mesma chave k para recuperar m = DECk (c). 


\subsection{Administração e distribuição de chaves}

A principal vantagem da criptografia de chave simétrica é a alta eficiência, contudo, há significantes desvantagens destes sistemas. Uma delas é o conhecido problema da distribuição de chave - a necessidade de um canal que seja ambos, secreto e autenticado, para a distribuição das chaves. Em algumas aplicações, esta distribuição pode ser convenientemente feita por usar um canal fisicamente seguro tal como um emissário de confiança. Outra maneira é usar os serviços de uma terceira parte confiável on-line que inicialmente estabelece chaves secretas com todas as entidades na rede e conseqüentemente usa essas chaves para distribuir as informações de chaves para as entidades em comunicação quando requerido \footnote{Este modo de usar uma Terceira parte centralizada para distribuir chaves para algoritmos de chave simétrica às partes conforme elas necessitarem é usado pelo protocolo de autenticação da rede Kerberos para aplicações cliente/servidor.}. Soluções como esta podem ser bem apropriadas para ambientes onde uma autoridade central aceitável e confiável, mas é claramente impraticável em aplicações tal como e-mail na internet.

Uma segunda desvantagem é o problema de administração de chaves. - em uma rede de N entidades cada entidade pode ter que manter diferentes informações de chaves com cada uma das N-1 entidades. Logo, seriam necessárias N(N-1)/2 chaves privadas em toda a rede o que inviabiliza a administração quando N se torna grande. Este problema pode ser aliviado usando serviços de uma terceira parte on-line que distribui as chaves conforme sãs requeridas, assim reduzindo a necessidade das entidades de armazenar múltiplas chaves seguramente. Novamente, contudo, tais soluções não são práticas em alguns cenários. Finalmente, uma vez que a informação sobre as chaves é compartilhada entre duas (ou mais) entidades, técnicas de chave simétrica não podem ser usadas para implementar esquemas de assinatura digital (DSS) elegantes que forneçam serviços de irretratabilidade. Isto porque é impossível distinguir entre as ações tomadas por diferentes detentores de uma chave secreta. \footnote{Esquemas de assinaturas digitais podem ser implementados usando técnicas de chave simétrica; contudo, estes esquemas geralmente impraticáveis conforme requerido seu uso de uma terceira parte confiável on-line ou novas informações de chaves para cada assinatura.}

\section{Criptografia de chave pública}

\subsection{Introdução}
A noção de criptografia de chave pública, foi introduzida em 1975 por Diffie, Hellman e Merkle para resolver as deficiências da criptografia de chaves simétricas mencionadas anteriormente. Em contrate aos esquemas de chave simétrica, os esquemas de chave pública requerem apenas que as entidades em comunicação troquem informações de chaves que são autenticas (mas não secretas). Cada entidade seleciona um único par (e,d) consistindo de uma chave pública e, e uma chave privada relacionada d que a entidade mantém secreta). As chaves têm a propriedade de que é computacionalmente impraticável determinar a chave privada apenas de conhecimento da chave pública.

\subsection{Confidencialidade}

Se a entidade A deseja enviar uma mensagem confidencial m para uma entidade B, ela obtém uma cópia autêntica da chave pública de B eB, e usa a função de encriptação ENC de uma esquema de chave pública para computar a cifra c = ENCeB (m). A então transmite c para B, que usa a função de decriptação DEC e sua chave privada dB para recuperar a mensagem clara: m = DECdB (c). A presunção é que um agressor com posse apenas de eB (mas não de dB) não consegue decriptar c. Observe que não há nenhuma necessidade de discrição de eB. É essencial apenas que A obtenha uma cópia autentica de eB - por outro lado A encriptaria m usando a chave pública eE de alguma entidade E tentando personificar B, e m seria recuperável por E.

\subsection{Irretratabilidade}

Esquemas de assinatura digital podem ser desenvolvidos para autenticação da origem e integridade dos dados, e para facilitar o fornecimento de serviços de irretratabilidade. Uma entidade A usaria o algoritmo de geração de assinatura SIGN de um esquema de assinatura digital e sua chave privada dA para computar a assinatura da mensagem: s = SIGNdA (m). Ao receber m e s, uma entidade B que tem uma cópia autentica da chave pública de A eA usa um algoritmo de assinatura de verificação para confirmar que s foi de fato gerado a partir de m e dA. Uma vez que dA é presumivelmente conhecido por A, B está assegurado de que a mensagem foi realmente originada por A. Ademais, uma vez que a verificação requer apenas quantidades não secretas m e eA, a assinatura s para m pode também ser verificada por uma terceira parte que poderia estabelecer contestações se A negar ter assinado a mensagem m. Diferente das assinaturas escritas à mão, a assinatura s de A depende da mensagem m sendo assinada, prevenindo um forjador de simplesmente acrescentar s a uma mensagem $\sim m$ linha e afirmar que A assinou $\sim m$. Mesmo embora havendo nenhuma necessidade de segredo com relação à chave pública eA, é essencial que os verificadores devessem usar uma cópia autêntica de eA quando verificar assinaturas personificadamente geradas por A.

Deste modo, a criptografia de chave pública fornece soluções elegantes para os três problemas com criptografia de chave simétrica, chamados distribuição de chaves, administração de chaves e suporte à irretratabilidade. Deve-se notar que embora necessidade de um canal secreto para distribuição de chaves foi eliminado, implementar uma infra-estrutura de chave pública (PKI) para distribui e administrar chaves públicas pode ser um desafio formidável na prática. Também, operações em chave pública são normalmente significantemente mais lentas do que seus respectivos na criptografia de chave simétrica. Portanto, sistemas híbridos que beneficiam desde a eficiência dos algoritmos de chave simétrica e a funcionalidade dos algoritmos de chave pública são freqüentemente usados.

Em um esquema de chave pública, um par de chaves é selecionado para que o problema de calcular a chave privada a partir da chave pública é equivalente para resolver um problema computacional que é considerado intratável. Os problemas teóricos numéricos cuja intratabilidade constrói a base para a segurança dos esquemas comumente usados são:

\begin{itemize}
\item O problema da fatoração de inteiros, cuja dificuldade é essencial para a segurança da encriptação RSA e esquemas de assinatura.
\item O problema do logaritmo discreto, cuja dificuldade é essencial para a segurança da encriptação de chave pública ElGamal e esquemas de assinatura e suas variantes tais como o Digital Signature Algorithm (DSA).
\item O problema do logaritmo discreto em curvas elípticas, cuja dificuldade é essencial para a segurança de todos os esquemas baseados em curvas elípticas.
\end{itemize}

\section{Logaritmos Discretos}

\subsection{Problemas Baseados em Logaritmos Discretos}

O primeiro sistema baseado em logaritmo discreto foi o protocolo de troca de chaves proposto por Diffie e Hellman em 1976. Em 1984, ElGamal descreveu a encriptação de chave pública baseada em DL e esquemas de assinatura. Desde então, muitas variantes destes esquemas foram propostas. Logo em seguida apresentamos o esquema de encriptação básico de chave pública ElGamal e o Digital Signature Algorithm (DSA).


\subsection{Geração de chaves com Logaritmos Discretos}

Em sistemas de logaritmos discretos, um par de chaves está associado com um conjunto de parâmetros públicos do domínio ($p$,$q$, $g$). Aqui, $p$ é um primo, $q$ é um divisor primo de $p-1$, e $g \in [1,p-1]$ tem ordem $q$ (i.e., $t=q$ é o menor inteiro positivo satisfazendo $gt \equiv 1(mod p)$.
Uma chave privada é um inteiro x que é selecionado uniformemente de modo aleatório no intervalo $[1,q-1]$ (esta operação é denotada $x \in [1,q-1]$, e a chave pública correspondente é $y=g^{x}mod p$. O problema de determinar $x$ dados os parâmetros do domínio ($p$,$q$, $g$) e $y$ é o problema do logaritmo discreto (DLP).


\section{Histórico das curvas elípticas}
O estudo das curvas elípticas, por matemáticos, data da metade do século XIX. Como conseqüência, encontramos hoje uma vasta literatura sobre o assunto. Em 1984, Hendrik Lenstra descreve um engenhoso algoritmo para fatorar inteiros que recai nas propriedades das curvas elípticas. Esta descoberta motivou os pesquisadores a investigar novas aplicações em criptografia sobre curvas elípticas e teoria dos números computacional.

A criptografia de chave pública foi concebida em 1976 por Whitfield Diffie e Martin Hellman. Sua primeira construção prática se seguiu em 1977 quando Ron Rivest, Adi Shamir e Len Adleman propuseram o protocolo agora tão conhecido RSA cuja segurança é baseada na intratabilidade do problema da fatoração de inteiros. A criptografia baseada em curvas elípticas (ECC) foi descoberta em 1985 por Neal Koblitz e Victor Miller.

 Os protocolos de ECC são mecanismos de criptografia de chave pública e fornecem as mesmas funcionalidades que o esquema proposto no RSA. Contudo, sua segurança é baseada na dificuldade de um diferente problema, o problema do logaritmo discreto em curvas elípticas (ECDLP), que é um pouco mais difícil de se resolver. Atualmente, os melhores algoritmos para resolver o ECDLP levam tempo completamente exponencial, enquanto que para o problema da fatoração de inteiros do RSA, o tempo é sub-exponencial. Isso significa que o nível de segurança desejado pode ser obtido com chaves significativamente menores que as usadas no RSA. Por exemplo, o nível de segurança determinado por uma chave de 160 bits em sistemas ECC é equivalente para o obtido usando-se RSA com chaves de 1024 bits. 
As vantagens obtidas com tamanhos de chaves menores são velocidade e uso eficiente de energia, largura de banda e armazenamento.

Desde então, grande quantidade de pesquisas começou a ser publicada na segurança e implementação eficiente em ECC. No fim dos anos 90, sistemas sobre curvas elípticas começaram a receber aceitação comercial quando organizações de padrões respeitadas especificaram protocolos sobre curvas elípticas, e empresas privadas incluíram estes protocolos nos seus produtos de segurança. Hoje, ECC é considerado o estado-da-arte em criptografia de chave pública.



\section{Curvas Elítpticas}

Os sistemas baseados em logaritmos discretos apresentados anteriormente podem ser descritos na configuração de um grupo cíclico finito. A definição de grupos segue abaixo.

\subsection{Grupos}

Um grupo abeliano ($G$,$*$) consiste de um conjunto G com uma operação binária * : $G x G \rightarrow G$ satisfazendo as seguintes propriedades:
	(Associatividade) $a * (b * c)$ = $(a * b) * c$ para todos os $a,b, c \in G$
	(Existência de uma identidade) Existe um elemento $e \in G$ tal que $a*e = e*a = a$ para todo $a \in G$.
	(Existência de inversos) Para cada $a \in G$, existe um elemento $b \in G$, chamado inverso de $a$, tal que $a * b = b * a = e$.
	(Comutatividade) $a * b = b * a$ para todos $a$, $b \in G$.


A operação do grupo é geralmente chamada de adição (+) ou multiplicação (-). Em primeira instância, o grupo é chamado de grupo aditivo, o elemento (aditivo) identidade é normalmente denotado por 0, e o inverso (aditivo) d e a é denotado por -a. Em uma segunda instância, o grupo é chamado de grupo multiplicativo, o elemento (multiplicativo) identidade é denotado por 1, e o inverso (multiplicativo) de a é denotado por a-1 .
O grupo é finito se G é um conjunto finito, no caso em que o número de elementos em G é chamado a ordem de G.
Por exemplo, seja p um numero primo, e $Fp$ = {0,1,2,...,p-1} denota o conjunto dos inteiros módulo $p$. Então (Fp,+), onde a operação + é definida com a operação de adição de inteiros módulo p, é um grupo finito aditivo de ordem p com elemento identidade (aditivo) 0. Além isso, ($F*p$,$\bullet$), onde F*p denota os elementos diferentes de zero em Fp e a operação $\bullet$ é definida como a multiplicação de inteiros módulo $p$, é um grupo finito multiplicativo de ordem $p-1$ com elemento identidade (multiplicativo) 1. A tripla ($Fp$, $+$ , $\bullet$) é um campo finito, denotado mais sucintamente por $Fp$.

Agora, se $G$ é um grupo finito multiplicativo de ordem $n$ e $g \in G$, então o menor inteiro positivo $t$ tal que $gt = 1$ é chamado de ordem de g; esse t sempre existe e é divisor de n. O conjunto $<g> = {gi : 0 \leq i \leq t-1}$ de todas as potências de $g$ é ele próprio um grupo sobre a mesma operação como $G$, e é chamado um subgrupo cíclico de $G$ gerado por $G$. Declarações análogas são verdadeiras se $G$ é escrito aditivamente. Assim, a ordem de g   G é o menor divisor positivo $t$ de $n$ tal que $tg = 0$, e $<g> = {ig : 0 \leq i \leq t-1}$. Aqui, tg denota o elemento obtido por adicionar t cópias de $g$. Se G tem um elemento $g$ de ordem $n$, então $G$ é dito ser um grupo cíclico e $g$ é um gerador de G. Por exemplo, com o os parâmetros do DL ($p$,$q$, $g$) definidos anteriormente, o grupo multiplicativo $(F*p, \bullet)$ é um grupo cíclico de ordem p-1. Ademais, $<g>$ é um subgrupo cíclico de ordem $q$.

 
\subsection{Grupos em Curvas Elípticas}

Seja p um número primo, e $Fp$ o campo dos inteiros módulo $p$. Uma curva elíptica $E$ sobre $Fp$ é definida por uma equação da forma 
\begin{equation}
\label{eq:defcurvaeliptica}
y^2= x^3+ ax+b
\end{equation}
onde $a$, $b$   $Fp$ satisfaz $4a^{3}+ 27b^{2}=0 (mod p)$. Um par ($x$, $y$), onde $x$, $y$    $Fp$, é um ponto na curva se ($x$, $y$) satisfaz a equação \ref{eq:defcurvaeliptica}. O ponto no infinito, denotado por $\infty$, também é considerado estar contido na curva. O conjunto de todos os pontos sobre $E$ é denotado pro $E(Fp)$. Por exemplo, se $E$ é uma curva elíptica sobre $F7$ com definida pela equação:

\begin{equation}
\label{eq:defcurvaeliptica2}
y^2= x^3+ 2x+4
\end{equation}

 Então, os pontos sobre $E$ são:

$E(F7) = { \infty, (0,2), (0,5), (1,0), (2,3), (2,4), (3,3), (3,4), (6,1), (6,6) }$.

Agora, há um método bem conhecido para somar 2 pontos numa curva elíptica $P: (x1, y1)$ e $Q: (x2, y2)$ para produzir um terceiro ponto na curvar $R: (x3, y3)$. Veja a figura seguinte:



\begin{figure}[ht]
	\centering
		\includegraphics{figuras/SomaEliptica.PNG}
	\caption{Soma em Curva Elíptica}
	\label{fig:somaeliptica}
\end{figure}


A regra de adição requer algumas operações aritméticas (adição, subtração, multiplicação e inversão) in fp com as coordenadas $x1, y1, x2, y2$. Com esta regra de adição, o conjunto dos pontos $E$ ($Fp$) forma um grupo abeliano (aditivo) com $\infty$ servindo como elemento neutro. Subgrupos cíclicos destes grupos sobre curvas elípticas podem ser agora usados para implementar sistemas de logaritmos discretos.

\subsection{Geração de chaves em curva elíptica}

Seja $E$ uma curva elíptica definida sobre o campo finito $Fp$. Seja $P$ um ponto em $E(Fp)$, e suponha que $P$ tenha ordem prima $n$. Então o subgrupo cíclico de $E(Fp)$ gerado por $P$ é 

$<P> = { \infty, P, 2P, 3P, ..., (n-1)P }.$

O primo $p$, a equação da curva elíptica $E$, e o ponto $P$ e sua ordem $n$, são os parâmetros públicos do domínio. Uma chave privada é um inteiro d que é selecionado uniformemente de forma aleatória no intervalo $[1,n-1]$, e a chave pública correspondente é $Q = dP$.
O problema de determinar d dados os parâmetros do domínio e Q é o problema do logaritmo discreto em curvas elípticas (ECDLP).

\subsection{Encriptação em curva elíptica}

Uma mensagem m é primeiramente representada como um ponto $M$, e então encriptada somando-se ela a $kQ$, onde $k$ é um inteiro aleatoriamente selecionado, e $Q$ é a chave pública do receptor. O emissor transmite os pontos $C1 = kP$ e $C2 = M + kQ$ para o receptor que usa sua chave privada $d$ para calcular $dC1 = d(kP) = k(dP) = kQ$, e, em seguida, recupera $M = C2 - kQ$. Um agressor que deseja recuperar $M$ precisa calcular $kQ$. Esta tarefa de computar $kQ$ a partir dos parâmetros do domínio, $Q$, e $C1 = kP$, é um problema análogo ao problema de Diffie-Hellman em curvas elípticas.





\section{Emparelhamentos Bilineares}
%Dar uma introdução do que é emparalhamento, apresentar os emparelhamentos ATE e ETA
\section{Criptografia baseada em identidades}
%Explicar o que é isso para um leitor leigo
\section{Alternativas existentes}% (RSA, coisas mobile)
%Não sei o que escrever aqui... sacrificar???
\section{Revisão literatura} %????
%Hein? Que isso? Sacrificar talvez...


\chapter{Escolha de um esquema criptográfico adequado}

\subsection{Porque Criptografia baseada em curvas elípticas?}

Há vários critérios que precisam ser considerados ao selecionar-se uma família de esquemas de chave pública para uma determinada aplicação.

Os princípios são:
\begin{itemize}
\item Funcionalidade. A família de chave pública fornece as habilidades desejadas?
\item Segurança. O que garante que os protocolos são seguros?
\item Eficiência. Para o nível de segurança desejado, os protocolos fornecem os objetivos de eficiência.
\end{itemize}
Outros fatores que podem influenciar uma decisão incluem a existência de padrões de melhores práticas desenvolvidos por organizações de padronização confiáveis, a disponibilidade de produtos criptográficos comerciais, coberturas de patentes, e extensão das aplicações existentes.
As famílias do RSA, do logaritmo discreto e das curvas elípticas introduziram na criptografia de chave pública todas as funcionalidades básicas esperadas - encriptação, assinaturas e troca de chaves.
Durante os anos, pesquisadores desenvolveram técnicas para modelar e provar a segurança dos protocolos RSA, logaritmo discreto e curvas elípticas sob hipóteses razoáveis. A questão fundamental da segurança que permanece é a dificuldade do problema matemático subjacente que é necessário para a segurança de todos os protocolos em uma família de chave pública - o problema da fatoração inteira para sistemas RSA, o problema do logaritmo discreto para os sistemas baseados em logaritmos discretos e o problema de logaritmo discreto em curvas elípticas em sistemas baseados em curvas elípticas. A dificuldade percebida desses problemas impacta diretamente na eficiência uma vez que ela dita os tamanhos do domínio e dos parâmetros das chaves. Isso, por outro lado, afeta a eficiência das operações aritméticas subjacentes.


%Explicar aqui que analisamos os seguintes candidatos.
\section{BLMQ}

A primeira tentativa de solução adotava o esquema de cifrassinatura baseada em identidades BLMQ \cite{barreto-libert-mccullagh-quisquater}.



O esquema foi escolhido por, aparentemente, atender aos requisitos estabelecidos inicialmente. O BLMQ era notadamente mais eficiente que esquemas de criptografia baseada em identidades anteriores, como o de Boneh-Franklin \cite{boneh-franklin}, o que poderia tornar o uso desse tipo de criptografia viável em ambientes produtivos. Além disso, uma assinatura de 160 bits garantiria um nível de segurança de aproximadamente 80 bits equivalente ao do RSA de 1024 bits\cite{rsalabs}.

%TODO: escrever muito mais
%\subsection{Definições}
%TODO: vale a pena definir o algoritmo? O leitor vai jogar a monografia no chão
%quando descobrir que nada disso será usado...
\subsection{Testes de viabilidade}

%TODO: ajeitar essa seção... ta CTRL+C do WTICG, e essa tabela ta ruim...

%falar de tentativas de resolver os problemas, alguns sucessos e alguns fracassos
O esquema foi implementado na linguagem de programação Java, e testes foram realizados em um aparelho celular Nokia 6275.

O desempenho observado inicialmente foi insatisfatório, não atendendo aos requisitos de usabilidade estabelecidos na especificação. Foram feitas tentativas de melhoria do desempenho, como variação do tamanho das chaves, uso de diferentes funções de emparelhamento (Ate, Eta)\cite{freeman-scott-teske}, e implementações com diferentes bibliotecas que fornecessem a classe \emph{BigInteger} - a implementação da Sun se mostrou mais eficiente do que a implementação da Bouncy Castle. Algumas adaptações no esquema em si foram feitas, como inversão da ordem das curvas utilizadas. 

Os melhores resultados obtidos são apresentados na tabela~\ref{tab:BLMQ}.

\begin{table}[htr!]\centering
\caption{Testes com BLMQ}\label{tab:BLMQ}
\begin{tabular}{cccccc}\hline
Operação                   &  Tempo (s)\\\hline
Inicialização das classes  &  128.9\\\hline
Emparelhamento Eta         &  4.2\\\hline
Emparelhamento Ate          &  3.9\\\hline
\end{tabular}
\end{table}

%falar das BNCurves

%TODO: falar que cada operação consumuia x emparalhementos, por isso mto ruim

Como estes tempos não atendiam aos requisitos de usabilidade do projeto, fez-se necessário buscar alternativas. Estas dificuldades serviram como motivação para a criação de um esquema inovador. Como resultado de pesquisas realizadas, foi idealizado um novo esquema, apresentado em \cite{bdcps} e brevemente descrito a seguir.

\section{BDCPS}
%Falar aqui que o Barreto inventou o novo algoritmo, que publicou o SBSEG
Visando resolver os problemas encontrados com a utilização do BLMQ, um novo esquema foi criado, e designado por BDCPS. Um artigo \cite{bdcps} foi submetido para o SBSEG'08, sediado em Gramado - RS.

Na criação do novo esquema, em vez de utilizarmos exclusivamente criptografia e assinaturas baseadas em identidades, estendemos um esquema de criptografia sem certificados com um esquema de assinatura convencional, mas utilizando técnicas baseadas em identidades para validar a chave pública, evitando o uso de certificados \cite{bdcps}. A nova técnica mescla esses dois paradigmas, garantindo baixo tempo de cifrassinatura e de vericifração, tamanhos de chaves dentro dos limites adotados e níveis de segurança satisfatórios.

O esquema proposto integra esquemas preexistentes como as assinaturas BLMQ e Schnorr \cite{schnorr} e o esquema isento de certificados de Zheng\cite{zheng}. Neste esquema, a geração das chaves dos usuários dispensa a necessidade de uma autoridade certificadora e a utilização de certificados para validar sua chave pública. Estas características implicaram em importantes, mas não únicas, melhorias em relação ao esquema anteriormente implementado e serão discutidas na seção "Análise da Proposta". 
Por criptografia convencional entende-se o fato de o usuário poder escolher seu par de chaves não certificado, ou seja, ele escolhe apropriadamente uma chave privada e gera sua chave pública a partir dela. Desse modo, somente o usuário gerador de seu par de chaves convencional conhece sua chave privada, e este fato elimina a possibilidade de "Key Escrow", que é o comprometimento da chave e conseqüentemente das mensagens com ela encriptadas. 
O par de chaves não certificado é combinado com a solução de criptografia baseada em identidades para que seja posteriormente validado por outro usuário do sistema.
\subsection{Definições}
%Definir o algoritmo


O novo esquema consiste dos seguintes algoritmos: 


\begin{itemize}

\item \textbf{Setup:} Algoritmo gerador do conjunto dos parâmetros públicos necessários. 
O algoritmo escolhe um parâmetro de segurança $k$ e define:

$n:$  Um inteiro primo de k bits. 

$(\G_1,\G_2,\G_T)$ Grupos de mapeamento bilinear de ordem $n$  

$e: \G_1 \times \G_2 \rightarrow \G_T$: Emparelhamento eficientemente computável e não-degradado.

$P \in \G_1$, $Q \in \G_2$: Os pontos geradores dos grupos $\G_1$ e $\G_2$ respectivamente.

Resumos criptográficos \emph{(hashes)} 

$h_0: \G_T^2 \times \{0, 1\}^\ast \rightarrow \Z_n^\ast$,

$h_1: \G_T \times \{0, 1\}^\ast \rightarrow \Z_n^\ast$, % id hash

$h_2: \G_T \rightarrow \{0, 1\}^\ast$, % msg encryption hash

$h_3: (\G_T \times \{0, 1\}^\ast)^3 \rightarrow \Z_n^\ast$. % msg auth hash

Uma chave mestra $s \stackrel{R}{\gets} \Z_n^\ast$ também é escolhida, à qual a chave pública 
$P_{pub} = sP \in \G_1$ é associada. 

O gerador $g = e(P, Q) \in \G_T$ também é incluso entre os parâmetros públicos do sistema, $\texttt{params} = (k, n, \G_1, \G_2, \G_T, e, P, Q, g, P_{pub}, h_0, h_1, h_2, h_3)$.


\item \textbf{Set-Secret-Value:} dados $\texttt{params}$, o algoritmo toma $x_A \stackrel{R}{\gets} \Z_n^\ast$ como o valor secreto da identidade $A$. O usuário $A$ pode definir $x_A$, sua chave parcial privada, independente do algoritmo e, neste caso, será usada como uma senha comum.

\item \textbf{Set-Public-Value:} dado o valor secreto $x_A \in \Z_n^\ast$ da identidade $A$, computa $y_A \gets g^{x_A} \in \G_T$ como o valor público de $A$.

\item \textbf{Private-Key-Extract:} Obtém $\ID_A \in \{0, 1\}^\ast$, o identificador de $A$  e  o valor público $y_A \in \G_T$, e calcula a chave privada baseada em identidade de $A$, $Q_A \gets (h_1(y_A, \ID_A) + s)^{-1}Q \in \G_2$. A entidade $A$ consegue verificar a consistência desta chave checando se $e(h_1(y_A, \ID_A)P + P_{pub}, Q_A) = g$. Esta configuração é denominada estilo de chave Sakai-Kasahara ~\cite{sakai-kasahara}.

\item \textbf{Set-Private-Key:} dada a chave privada parcial da entidade $A$, $Q_A \in \G_2$ e o valor secreto $x_A \in \Z_n^\ast$, este algoritmo estabelece o par $(x_A, Q_A) \in \Z_n^\ast \times \G_2$ como o par completo da chave privada de $A$.

\item \textbf{Set-Public-Key:} dada a chave privada parcial de $A$, $Q_A \in \G_2$, o valor secreto $x_A \in \Z_n^\ast$, e o correspondente valor público $y_A \in \G_T$, o assinante toma $u_A \stackrel{R}{\gets} \Z_n^\ast$ e calcula
\begin{enumerate}
\item $r_A \gets g^{u_A}$
\item $h_A \gets h_0(r_A, y_A, \ID_A)$
\item $T_A \gets (u_A - x_A h_A) Q_A$
\end{enumerate}
A chave pública completa da entidade $A$ é a tripla $(y_A, h_A, T_A) \in \G_T \times \Z_n^\ast \times \G_2$. Este configuração é uma combinação da assinatura de Schnorr (sob a chave $x_A$) com a assinatura BLMQ (sob a chave $Q_A$) no valor público $y_A$ e a identidade $\ID_A$. 
% Na dúvida, comentei isso. Seria melhor se tivéssemos referências (de FAPIP, DLP)
% O difícil problema da falsificação de tal assinatura é o FAPIP em vez do DLP como em Schnorr; em outras palavras, ele consiste em calcular $Q_A' := x_A Q_A$ dados $y_A := g^{x_A}$ e $P_A' := h_1(y_A, \ID_A)P + P_{pub}$. Perceba-se que é fácil calcular $y_A$ dados $Q_A'$ e $P_A'$, uma vez que equivale a calcular $e(P_A', Q_A')$ (e verificando que $P_A' = h_1(e(P_A', Q_A'), \ID_A)P + P_{pub}$).

\item \textbf{Public-Key-Validate:} dada a chave pública completa da entidade $A$, $(y_A, h_A, T_A)$, este algoritmo verifica que $y_A$ tem ordem $n$ (i.e. que $y_A \neq 1$ mas $y_A^n = 1$) e calcula
\begin{enumerate}
\item $r_A \gets e(h_1(y_A, \ID_A)P + P_{pub}, T_A) y_A^{h_A}$
\item $v_A \gets h_0(r_A, y_A, \ID_A)$
\end{enumerate}
O verificador aceita a mensagem se, e somente se $v_A = h_A$. O processo de validação combina a verificação da assinatura Schnorr com a verificação da assinatura BLMQ.

\item \textbf{Signcrypt:} Para encriptar $m \in \{0, 1\}^\ast$ sob a chave pública do receptor $y_B \in \G_T$ previamente validade para a identidade $\ID_B$ e $P_{pub}$, e a chave privada do emissor $x_A \in \Z_n^\ast$, chave pública $y_A \in \G_T$ e a identidade $\ID_A$, o emissor toma $u \stackrel{R}{\gets} \Z_n^\ast$ e calcula
\begin{enumerate}
\item $r \gets y_B^u$
\item $c \gets h_2(r) \oplus m$
\item $h \gets h_3(r, m, y_A, \ID_A, y_B, \ID_B)$ \label{eq:auth}
\item $z \gets u - x_A h$ \label{eq:sign}
\end{enumerate}
O criptograma de assinatura é a tripla $(c, h, z) \in \{0, 1\}^\ast \times \Z_n^2$. Comparado ao método de cifrassinatura de Zheng, as identidades de ambos o emissor e o destinatário são inclusas na equação de autenticação~\ref{eq:auth}, e a equação de assinatura~\ref{eq:sign} segue o estilo Schnorr em vez do dedicado, porém levemente mais complicado(devido à presença da inversão de campos), estilo Zheng, similar ao DSA \cite{nist-fips-186-2}.

\item \textbf{Unsigncrypt:} dada a chave pública do emissor $y_A \in \G_T$ previamente validade para a identidade $\ID_A$ e $P_{pub}$, e a chave privada do receptor $x_B \in \Z_n^\ast$, a chave pública $y_B \in \G_T$ e a identidade $\ID_B$, sob a recepção da tripla $(c, h, z)$ o receptor verifica se $h, z \in \Z_n^\ast$ e calcula
\begin{enumerate}
\item $r \gets y_A^{h x_B} y_B^z$ \label{eq:nonce-rec}
\item $m \gets h_2(r) \oplus c$
\item $v \gets h_3(r, m, y_A, \ID_A, y_B, \ID_B)$
\end{enumerate}
O receptor aceita a mensagem se, e somente se, $v = h$. A equação \ref{eq:nonce-rec} é levemente mais simples que seu correlato em Zheng devido ao estilo Schnorr adotado para a cifrassinatura.

\end{itemize}

%Como uma observação, notamos que o mecanismo de validação da chave pública(algoritmos \textbf{Set-Public-Key} e \textbf{Public-Key-Validate}), pela sua combinação de assinaturas convencionais Schnorr e assinaturas baseadas em identidade BLMQ, constitui-se de um esquema de assinatura sem certificado e portanto tem interesse independente.


\subsection{Testes de viabilidade}
%Tabelinha de testes preliminares, mostrar que ficou bonzão!
O novo esquema também foi implementado na plataforma JME (\emph{Java Platform Micro Edition}), e testes para validar a viabilidade foram feitos em diversos modelos de aparelhos celulares, além dos emuladores dos ambientes de desenvolvimento \emph{Eclipse} e \emph{NetBeans}.

Os resultados foram satisfatórios, já que os tempos de cifrassinatura e vericifração estão de acordo com as métricas estabelecidas e bem mais eficientes em relação ao esquema inicialmente adotado. 

O tempo necessário para validar uma chave pública é um pouco maior do que para as demais operações. Porém, conforme observado anteriormente, esta é uma operação que será executada apenas uma vez para cada nova identidade que se deseje validar. A chave validada fica armazenada na memória do aplicativo, não sendo necessário validá-la novamente em uma comunicação futura com o mesmo par.

Os resultados dos testes são apresentados nas tabelas \ref{tab:bdcps127} e \ref{tab:bdcps160}. Foram feitos testes com chaves de 127 e 160 bits, para dois modelos distintos de celulares, Nokia 6275 e Sony Ericsson W200i.

\begin{table}[htr!]\centering
\caption{Testes com o novo esquema (chaves de 127 bits) e comparação com o RSA}\label{tab:bdcps127}
\begin{tabular}{cccccc}\hline
Operação                   & Tempo Nokia 6275 (s)   &  Tempo Sony Ericsson W200i (s) \\\hline
Emparelhamento Eta         & 7,30                   &  2,37                          \\\hline
Emparelhamento Ate         & 7,43                   &  2,38                          \\\hline
Private-Key-Extract        & 2,63                   &  0,93                          \\\hline
Check-Private-Key          & 9,31                   &  2,92                          \\\hline
Set-Public-Value           & 0,66                   &  0,22                          \\\hline
Set-Public-Key             & 3,40                   &  1,15                          \\\hline
Public-Key-Validate        & 10,50                  &  3,35                          \\\hline
Signcrypt                  & 0,57                   &  0,21                          \\\hline
Unsigncrypt                & 0,80                   &  0,29                          \\\hline
Private RSA-508            & 1,05                   &  0,39                          \\\hline
Public RSA-508             & 0,03                   &  0,02                          \\\hline
\end{tabular}
\end{table}

\begin{table}[htr!]\centering
\caption{Testes com o novo esquema (chaves de 160 bits) e comparação com o RSA}\label{tab:bdcps160}
\begin{tabular}{cccccc}\hline
Operação                   & Tempo Nokia 6275 (s)   &  Tempo Sony Ericsson W200i (s) \\\hline
Emparelhamento Eta         & 10,53                  &  3,59                          \\\hline
Emparelhamento Ate         & 10,54                  &  3,64                          \\\hline
Private-Key-Extract        & 3,72                   &  1,32                          \\\hline
Check-Private-Key          & 12,70                  &  4,46                          \\\hline
Set-Public-Value           & 0,96                   &  0,33                          \\\hline
Set-Public-Key             & 4,96                   &  1,63                          \\\hline
Public-Key-Validate        & 14,94                  &  5,12                          \\\hline
Signcrypt                  & 0,77                   &  0,31                          \\\hline
Unsigncrypt                & 1,22                   &  0,45                          \\\hline
Private RSA-640            & 1,85                   &  0,74                          \\\hline
Public RSA-640             & 0,16                   &  0,03                          \\\hline
\end{tabular}
\end{table}

\section{Conclusão} %TODO: mudar o nome dessa seção, conclusão é muito ambíguo
%Falar que escolhemos o BDCPS e trabalharemos com ele daqui pra frente

Pode-se verificar a partir das tabelas \ref{tab:bdcps127} e \ref{tab:bdcps160} que os tempos de assinatura e verificação no algoritmo proposto são menores do que os tempos do RSA, para o mesmo nível de segurança. 

Dado que o tempo de uso do RSA de 1024 bits está no fim, uma nova versão será necessária \cite{rsalabs}. Contudo, para um aumento no nível de segurança do RSA, é preciso aumentar o tamanho das chaves, o que será um impacto razoável nos tempos de assinatura e verificação, uma vez que o aumento é relativamente grande. Em paralelo, um aumento equivalente no nível de segurança do BDCPS, acarreta menor aumento no tamanho das chaves e os impactos nos tempos das operações são menores. Este fato ocorre devido à relação entre o nível de segurança do BDCPS e o tamanho das chaves, que é uma relação diretamente proporcional.

\chapter{Especificação do sistema}

\section{Requisitos funcionais}
%Copiar do doc velho, mas adaptando bastantes às mudanças
\section{Requisitos não-funcionais}
%Copiar do doc velho, mas adaptando bastantes às mudanças
\section{Arquitetura}
%Diag de arquitetura, pequenas considerações, seção bem curta
\section{Classes}
%Diag de classes aqui, e descrição das classes
\section{Casos de uso}
%Diag de casos de uso, e descrição do fluxo

\begin{enumerate} 
\item Cadastrar-se no sistema
	 \begin{enumerate} 
	 \item Descrição: Novo usuário deseja usar o sistema pela primeira vez e precisa efetuar as configurações necessárias para poder receber sua chave privada.
   \item Evento Iniciador: Usuário seleciona a opção de primeiro uso do sistema
	 \item Atores: Usuário, KGB.
	 \item Pré-condição: Sistema de SMS seguro apresentando sua tela inicial.
	 \item Seqüência de Eventos: 
	 \begin{enumerate}
			\item Usuário seleciona o botão de primeiro uso.
			\item Sistema pede a entrada de uma nova senha privada do usuário.
			\item Usuário cadastra uma nova senha no sistema e confirma.
			\item Sistema exibe notificação de envio de mensagem de controle para a KGB.
			\item Usuário confirma o envio e sistema transmite a mensagem.
			\item Ao receber a mensagem, a KGB gera a chave privada do usuário e retorna uma mensagem segura contendo a chave gerada.
			\item O sistema do usuário recebe a mensagem da KGB contendo sua chave privada.
			\item Sistema pede novamente a senha do usuário e extrai a chave privada do usuário
			\item O sistema verifica se a chave privada recebida é válida.
			\item O sistema armazena a nova chave no celular.
		\end{enumerate}
		\item Pós-Condição: Sistema volta para a tela inicial e usuário está apto a autenticar novos contatos para trocar mensagens.
		\item Extensões: 
		\begin{enumerate}
		\item Caso haja algum problema na geração ou na mensagem que contém a chave privada do usuário ou ainda se outra entidade tentou se passar por KGB então o sistema exibe mensagem de chave inválida ao usuário.
		\end{enumerate}
\end{enumerate}
		
\item Autenticar novo contato
		\begin{enumerate}
		\item Descrição: Quando um usuário quiser trocar mensagem com um contato que ainda não foi autenticado pelo Sistema de SMS Seguro deverá requisitar sua autenticação.
		\item Evento Iniciador: Usuário deseja autenticar um novo contato para enviá-lo uma mensagem.
		\item Atores: Usuário que quer se comunicar, usuário recebedor da mensagem.
		\item Pré-condição: Sistema exibe tela inicial.
		\item Seqüência de Eventos: 
		\begin{enumerate}
			\item Usuário seleciona a opção de autenticar novo contato.
			\item Usuário insere o número do telefone do novo contato e seleciona ok.
			\item Sistema exibe notificação de envio de SMS para o contato informado.
			\item Usuário confirma o envio da mensagem SMS.
			\item Sistema envia requisição de autenticação para o novo contato.
		\end{enumerate}
    \item Pós-Condição: Sistema volta para a tela inicial.
		\item Extensões: 
		\begin{enumerate}
			\item Sistema exibe notificação de erro no envio da mensagem caso o serviço de envio esteja indisponível. (Passo v).
		\end{enumerate}
		\end{enumerate}
	
\item Enviar Mensagem
  	\begin{enumerate}
  	\item Descrição: Usuário deseja compor e enviar uma nova mensagem SMS para outro usuário.
  	\item Evento Iniciador: Usuário seleciona botão de envio de nova mensagem.
  	\item Atores: Usuário emissor da mensagem.
  	\item Pré-condição: Sistema de SMS seguro apresentando sua tela inicial.
  	\item Seqüência de Eventos: 
  	\begin{enumerate}
  	\item Usuário emissor da mensagem seleciona botão de envio de mensagem. 
		\item Sistema exige que o usuário indique o destinatário da mensagem.
		\item Usuário seleciona o destino da lista de contatos exibida.
		\item Usuário compõe a mensagem a ser enviada
		\item	Usuário confirma o envio da mensagem para o destinatário escolhido.
		\item Sistema exibe notificação de envio da mensagem.
		\end{enumerate}
	  \item Pós-Condição: A notificação de mensagem enviada é exibida e o sistema retorna à tela inicial.
		\item Extensões: 
		\begin{enumerate}
		\item Sistema exibe notificação de erro no envio da mensagem caso o serviço de envio esteja indisponível. (Passo v).
		\end{enumerate}
		\item Inclusões
		\begin{enumerate}
		\item Sistema busca todos os contatos da lista de contatos do celular para exibi-los.
		\item	Caso de uso 4.
		\end{enumerate}
		\end{enumerate}

\item Recepção de Mensagem
	\begin{enumerate}
	\item Descrição: Quando uma nova mensagem chega no celular o sistema deve captá-la e fazer seu tratamento.
	\item Evento Iniciador: Chega uma nova mensagem do Sistema de SMS Seguro no celular de um usuário.
	\item Atores: Sistema operacional.
	\item Pré-condição: Celular do usuário ligado.
	\item Seqüência de Eventos:
	\begin{enumerate}
	\item Celular recebe a nova mensagem e a coloca na fila.
	\item	Sistema operacional do celular capta a mensagem e requisita ao usuário que inicialize a aplicação caso ela não esteja em execução.
	\item	O sistema identifica a primitiva da mensagem e trata de forma correspondente.
	\end{enumerate}
	\item Pós-Condição: a mensagem está processada e o sistema está exibindo a tela inicial.
	\item Extensões: 
	\begin{enumerate}
	\item	Sistema trata mensagem cifrada e assinada. (Passo iii)
	\item	Sistema trata mensagem de autenticação de usuário.(Passo iii)
	\item	Sistema trata mensagem de pedido da chave privada. (Passo iii)
	\item	Sistema trata mensagem de entrega de chave privada. (Passo iii)
	\end{enumerate}
\end{enumerate}

\item Encriptação/Assinatura de Mensagem
		\begin{enumerate}
		\item Descrição: Usuário escreveu uma mensagem para alguém e deseja cifrá-la e assiná-la.
		\item Evento Iniciador: Usuário requisita envio de mensagem cifrada e assinada ao sistema.
		\item Atores: Usuário que deseja enviar uma mensagem segura.
		\item Pré-condição: Usuário está com a mensagem pronta na tela de envio.
		\item Seqüência de Eventos:
		\begin{enumerate}
		\item	Usuário seleciona a opção de enviar a mensagem.
		\item	Sistema cifra e assina a mensagem e exibe tela de confirmação de envio.
		\item	Usuário confirma o envio e sistema transmite a mensagem segura.
		\end{enumerate}
		\item Pós-Condição: Sistema volta para a tela inicial.
		\end{enumerate}

\item Verificar Mensagem
  	\begin{enumerate}
  	\item Descrição: Usuário deseja visualizar uma mensagem na sua caixa de entrada.
		\item Evento Iniciador: Usuário abre a caixa de entrada do sistema.
		\item Atores: Usuário.
		\item Pré-condição: Sistema de SMS seguro apresentando mensagens recebidas na caixa de entrada.
		Seqüência de Eventos: 
		\begin{enumerate}
		\item	Usuário escolhe a mensagem que deseja visualizar e seleciona ok.
		\item	Sistema verifica e decifra a mensagem.
		\item	Sistema exibe a mensagem clara para que o usuário possa lê-la.
		\end{enumerate}
		\item Pós-Condição: Sistema exibindo mensagem clara para o usuário.
		\end{enumerate}
\end{enumerate}


\section{Especificação do protocolo}

%Falar das nossas primitivas, como é feita serialização dos bytes em cada mensagem, etc
%Deixa que eu faço (Eduardo)

O intercâmbio de mensagens entre clientes, ou entre um cliente e a KGB, se dá através do envio de mensagens  binárias de SMS. Em nosso protocolo existem 4 tipos de mensagens (4 primitivas). Nesta seção apresentamos como é feita a divisão de bytes em cada tipo de mensagem. \footnote{Os bytes de uma mensagem serão numerados iniciando de 1.}

\subsection{RequestMyQAMessage}
Representa a mensagem que um cliente A envia para KGB contendo sua chave pública $y_A$.

\begin{itemize}
	\item Byte 1: Byte fixo que identifica uma mensagem do nosso protocolo. Valor 0x50.
	\item Byte 2: Byte fixo identifica a primitiva RequestMyQAMessage. Valor 0x00.
	\item Byte 3: Leva o valor do número de bits K usado na operação, como um inteiro sem sinal.
	\item Byte 4: Byte reservado para algum possível uso em uma versão futura. Nesta versão tem valor 0x00.	
	\item Byte 5: Armazena um número que informa o comprimento em bytes do parâmetro $y_A$.
\end{itemize}	
A partir do byte 6, ocorre o armazenamento dinâmico dos parâmetros. É reservado para cada parâmetro o espaço especificado nos bytes anteriores.
\begin{itemize}
	\item Parâmetro 1: O $y_A$.
\end{itemize}

\begin{figure}[ht]
	\centering
		\includegraphics{figuras/requestmyqamessage.PNG}
	\caption{RequestMyQAMessage}
	\label{fig:requestmyqamessage}
\end{figure}

\subsection{HereIsYourQAMessage}
Representa a mensagem que a KGB envia a um usuário A sua chave privada parcial $Q_A$ gerada a partir de e encriptada usando a chave pública $y_A$ do usuário. Somente um usuário em posse do $x_A$ associado ao $y_A$ poderá abrir o $Q_A$ contido nesta mensagem.

\begin{itemize}
	\item Byte 1: Byte fixo que identifica uma mensagem do nosso protocolo. Valor 0x50.
	\item Byte 2: Byte fixo identifica a primitiva HereIsYourQAMessage. Valor 0x01.
	\item Byte 3: Leva o valor do número de bits K usado na operação, como um inteiro sem sinal.
	\item Byte 4: Byte reservado para algum possível uso em uma versão futura. Nesta versão tem valor 0x00.	
	\item Byte 5: Armazena um número que informa o comprimento em bytes do parâmetro $c$.
	\item Byte 6: Armazena um número que informa o comprimento em bytes do parâmetro $h$.
	\item Byte 7: Armazena um número que informa o comprimento em bytes do parâmetro $z$.
\end{itemize}	
A partir do byte 8, ocorre o armazenamento dinâmico dos parâmetros. É reservado para cada parâmetro o espaço especificado nos bytes anteriores.
\begin{itemize}
	\item Parâmetro 1: Parâmetro $c$, parte do criptograma.
	\item Parâmetro 2: Parâmetro $h$, parte do criptograma.
	\item Parâmetro 3: Parâmetro $z$, parte do criptograma.	
\end{itemize}

\begin{figure}[h]
	\centering
		\includegraphics{figuras/hereisyourqamessage.PNG}
	\caption{HereIsYourQAMessage}	
	\label{fig:hereisyourqamessage}
\end{figure}

\subsection{AuthenticationMessage}
Representa a mensagem por onde um usuário envia sua chave pública $y_A$ para um outro usuário. Os parâmetros $h_A$ e $t_A$ também são enviados, pois serão usados pelo outro usuário para validar a chave pública $y_A$ (funcionam quase como um certificado para o $y_A$).

\begin{itemize}
	\item Byte 1: Byte fixo que identifica uma mensagem do nosso protocolo. Valor 0x50.
	\item Byte 2: Byte fixo identifica a primitiva AuthenticationMessage. Valor 0x02.
	\item Byte 3: Leva o valor do número de bits K usado na operação, como um inteiro sem sinal.
	\item Byte 4: Byte reservado para algum possível uso em uma versão futura. Nesta versão tem valor 0x00.	
	\item Byte 5: Armazena um número que informa o comprimento em bytes do parâmetro $y_A$.
	\item Byte 6: Armazena um número que informa o comprimento em bytes do parâmetro $h_A$.
	\item Byte 7: Armazena um número que informa o comprimento em bytes do parâmetro $T_A$.
\end{itemize}	
A partir do byte 8, ocorre o armazenamento dinâmico dos parâmetros. É reservado para cada parâmetro o espaço especificado nos bytes anteriores.
\begin{itemize}
	\item Parâmetro 1: Parâmetro $y_A$, a chave pública.
	\item Parâmetro 2: Parâmetro $h_A$.
	\item Parâmetro 3: Parâmetro $T_A$.
\end{itemize}

\begin{figure}[h]
	\centering
		\includegraphics{figuras/authenticationmessage.PNG}
	\caption{AuthenticationMessage}
	\label{fig:authenticationmessage}
\end{figure}


\subsection{SigncryptedMessage}
Representa uma mensagem cifrassinada a ser trocada entre usuários.

\begin{itemize}
	\item Byte 1: Byte fixo que identifica uma mensagem do nosso protocolo. Valor 0x50.
	\item Byte 2: Byte fixo identifica a primitiva SigncryptedMessage. Valor 0x03.
	\item Byte 3: Leva o valor do número de bits K usado na operação, como um inteiro sem sinal.
	\item Byte 4: Byte reservado para algum possível uso em uma versão futura. Nesta versão tem valor 0x00.	
	\item Byte 5: Armazena um número que informa o comprimento em bytes do parâmetro $c$.
	\item Byte 6: Armazena um número que informa o comprimento em bytes do parâmetro $h$.
	\item Byte 7: Armazena um número que informa o comprimento em bytes do parâmetro $z$.
\end{itemize}	
A partir do byte 8, ocorre o armazenamento dinâmico dos parâmetros. É reservado para cada parâmetro o espaço especificado nos bytes anteriores.
\begin{itemize}
	\item Parâmetro 1: Parâmetro $c$, parte do criptograma.
	\item Parâmetro 2: Parâmetro $h$, parte do criptograma.
	\item Parâmetro 3: Parâmetro $z$, parte do criptograma.	
\end{itemize}

\begin{figure}[h]
	\centering
		\includegraphics{figuras/signcryptedmessage.PNG}
	\caption{SignCryptedMessage}
	\label{fig:signcryptedmessage}
\end{figure}


\section{Escolha de parâmetros}
%Falar que escolhemos K = 176, escolha das curvas
\chapter{Implementação}

\section{Metodologia}
%TODO: Alguém faz ae... Não sei o que escrever aqui... sacrificar talvez?
\section{Ambiente de desenvolvimento}
%Netbeans, Wireless ToolKit, 
\section{Bibliotecas usadas}
%FLoggy, BouncyCastle, SMSPairings do Barreto
\section{Problemas encontrados}
%Falar dos problemas encontrados nesta etapa


%TODO: pitanga o que é isso de modelos?
%\chapter{Modelos}%, justificar o sistema
%Seria isso modelo de negócio? (vale a pena por na monografia)?

\chapter{Resultados}% (tabelas, etc, os objetivos foram alcançados? Testes, benchmarks)
\section{Desempenho}
%tabelas com os nossos tempos
\section{Comparação com outras soluções}
%!!!TODO
%tabelas com os nossos tempos

\chapter{Conclusão}
%Falar aqui do WTICG? 
\section{Análise dos resultados}
%Falar que os resultados foram muito bons, funcionou bem
\section{Possíveis desenvolvimentos futuros}% (ordenar artigos) ????

\bibliography{Monografia}

\appendix

\chapter{Apêndice}\label{app:apendiceA}

\end{document}
